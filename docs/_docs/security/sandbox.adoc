= The Ignite Sandbox

== Overview
Ignite allows using a user-defined code that can be a compute job, event filter, message listener, etc.
This user-defined code can utilize Java features to get access to host resources.
For example, it can create/update/delete files; create sockets; read/update/delete system properties; use reflection API and so on.
To restrict user-defined code options you may use the Ignite Sandbox based on the Java Sandbox model.

You can read about the Java Sandbox model link:https://docs.oracle.com/en/java/javase/11/security/java-se-platform-security-architecture.html#GUID-C203D80F-C730-45C3-AB95-D4E61FD6D89C[here,window=_blank].

== Ignite Sandbox activation

There are some conditions to activate the Ignite Sandbox.

- The first condition is _the SecurityManager must be installed_.

Due to the fact, that Ignite Sandbox is based on the Java Sandbox model, and the SecurityManager is an important part of that model, you need to have it installed.
The SecurityManager is responsible for checking, which security policy is currently in effect. It also performs access control checks.
The security manager is not automatically installed when an application is running. If you run Ignite as a separate application,
you must invoke the Java Virtual Machine with the `-Djava.security.manager` command-line argument (which sets the value of the `java.security.manager property`).
There is also a -Djava.security.policy command-line argument, defining, which policy files are utilized.
If you don't include `-Djava.security.policy` into the command line, then the policy files specified in the security properties file will be used.

You can read more about Security Management link:https://docs.oracle.com/javase/8/docs/technotes/guides/security/spec/security-spec.doc6.html#a19349[here,window=_blank].

NOTE: It may be convenient adding the security manager and the policy command-line arguments to `{IGNITE-HOME}/bin/ignite.sh|ignite.bat` script.
Read more about link:/quick-start/java#starting_a_node[starting a node].

NOTE: Ignite should have enough permissions to work correctly.
You may apply the most straightforward way that is granting to Ignite the `java.security.AllPermission` permission,
but you should remember the "giving permissions as low as possible" security principle.

- The second condition to activate the Ignite Sandbox is _an implementation of the `GridSecurityProcessor` interface must be installed_.

Currently, Apache Ignite does not provide an implementation of the `GridSecurityProcessor` interface out-of-the-box.
But, you can implement this interface as a part of link:/plugins[a custom plugin].

The `GridSecurityProcessor` interface has the `sandboxEnabled` method that manages a user-defined code execution inside the Ignite Sandbox.
By default, this method returns `false`, which means no-sandbox.
If you are going to use the Ignite Sandbox, your overridden `sandboxEnabled` method should return `true`.

If the Ignite Sandbox is turned on, you can see the following trace line:
[source,text]
----
[INFO] Security status [authentication=on, sandbox=on, tls/ssl=off]
----

== Permissions

A user-defined code is always executed on behalf of the security subject that initiates its execution.
The security subject's sandbox link:https://docs.oracle.com/en/java/javase/11/security/java-se-platform-security-architecture.html#GUID-DEA8EAB1-CF00-4658-AA6D-D2C9754C8B37[permissions,window=_blank] define actions that a user-defined code can perform.
The Ignite Sandbox gets these permissions using the `SecuritySubject#sandboxPermissions` method.

NOTE: A user-defined code, when running inside the Ignite Sandbox, may use the public API of Ignite without granting any additional permissions.

If a security subject doesn't have enough permissions to perform a security-sensitive operation,
an AcccessControlException appears.

[source,java]
----
// Get compute instance over all nodes in the cluster.
IgniteCompute compute = Ignition.ignite().compute();

compute.broadcast(() -> {
    // If the Ignite Sandbox is turned on, the lambda code is executed with restrictions.

    // You can use the public API of Ignite without granting any permissions.
    Ignition.localIgnite().cache("some.cache").get("key");

    // If the current security subject doesn't have the java.util.PropertyPermission("secret.property", "read") permission,
    // a java.security.AccessControlException appears here.
    System.getProperty("secret.property");
});
----

In the case of accessing the system property shown in the snippet above, you can see the following trace line with an exception:
[source,text]
----
java.security.AccessControlException: access denied ("java.util.PropertyPermission" "secret.property" "read")
----