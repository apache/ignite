<?php

/**
 * @file
 * Additional filter for Smarty input.
 */

/**
 * Set a message which reflects the status of the performed operation.
 *
 * If the function is called with no arguments, this function returns all set
 * messages without clearing them.
 *
 * @param $message
 *   The message should begin with a capital letter and always ends with a
 *   period '.'.
 * @param $type
 *   The type of the message. One of the following values are possible:
 *   - 'status'
 *   - 'warning'
 *   - 'error'
 * @param $repeat
 *   If this is FALSE and the message is already set, then the message won't
 *   be repeated.
 */
function session_set_message($message = NULL, $type = 'status', $repeat = TRUE) {
	if ($message) {
		if (!isset($_SESSION['messages'])) {
			$_SESSION['messages'] = array();
		}
		
		if (!isset($_SESSION['messages'][$type])) {
			$_SESSION['messages'][$type] = array();
		}
		
		if ($repeat || !in_array($message, $_SESSION['messages'][$type])) {
			$_SESSION['messages'][$type][] = $message;
		}
	}
	
	// messages not set when DB connection fails
	return isset($_SESSION['messages']) ? $_SESSION['messages'] : NULL;
}


function smarty_error_handler() {
  $args = func_get_args();
  if (strpos($args[1], 'Smarty error') === 0) {
    $GLOBALS['smarty_api']['error'] = $args;
  }
  if($GLOBALS['smarty_api']['prev_error_handler']){
    return call_user_func_array($GLOBALS['smarty_api']['prev_error_handler'], $args);
  }
}


/**
 * Implementation of hook_filter process(). Contains a basic Smarty evaluator.
 *
 * Evaluate Smarty code. Use with care.
 */
function smarty_filter_process($viewName, $variables = array()) {
	$smarty_options = array(
		'defaultStorage'=>'file',
		'php_handling' => 0,
	);
	$file = 'views/' . $viewName . '.html';
	$content = smarty_render_template($file, $variables, $smarty_options);
	return $content;
}

/**
 * Render a smarty template.
 *
 * @param $file
 *   The filename of the template to render.
 * @param $variables
 *   A keyed array of variables that will appear in the output.
 *
 * @return
 *   The output generated by the template.
 */
function smarty_render_template($file, $variables = array(),$options = array()) {
  // if smarty is broken, this should make sure the admin can still see the
  // menu to do something about it
  if ( !_smarty_init() ) {
    _smarty_error('no_init');
    return '';
  }
  // reuse the object to save time and allow 'global' smarty variables
  $smarty = _smarty_get_object();
  
  //<overall>
  // $smarty->templateDir =
  // Save current options and set new
  $saved_options = array();
  foreach ($options as $option_name => $option_value) {
    $saved_options[$option_name] = $smarty->$option_name;
    $smarty->$option_name = $option_value;
  }
  //</overall>
  $variables['context'] = array(
      'server' => $_SERVER,
      'session'=> $_SESSION,
      'request'=> $_REQUEST,
      'cookie' => $_COOKIE,          
  );

  //<overall>
  $GLOBALS['smarty_api']['error'] = FALSE;
  $GLOBALS['smarty_api']['prev_error_handler'] = set_error_handler('smarty_error_handler',E_ERROR);
  //</overall>  
  
  //-$options['cacheId']= $_GET['q'].'^'.serialize($user->roles); 
  
  if(isset($options['cacheId'])){
    $contents = $smarty->fetchCache($file,$options['cacheId'],$variables);
  }
  else{
    $contents = $smarty->fetch($file,$variables);
  }  

  //print '<br/>'.timer_read('sm');
  //<overall>
  restore_error_handler();
  if ($GLOBALS['smarty_api']['error']) {
    $contents = '<pre>'.print_r($GLOBALS['smarty_api']['error'], TRUE).'</pre>';
  }

  // Restore saved options
  foreach (array_keys($options) as $option_name) {
    $smarty->$option_name = $saved_options[$option_name];
  }
  //</overall>

  return $contents;
}

/**
* @function _smarty_init
* Include the Smarty class which is required by smarty;
* also check writeablility of the templates_c directory.
* A static variable is used so we only do the checks once.
*/
function _smarty_init() {
  static $ok; 
  if ( isset($ok) ) {
    return $ok;
  }
  $ok = TRUE;
  // find the Smarty class
  if (!class_exists('Sugar')) {  // prevent redeclaration
    $smarty_path = 'libs/Sugar.php';
    include_once $smarty_path;
    include_once SUGAR_ROOT.'/Sugar/Cache/File.php';
    if ( !class_exists('Sugar_Cache_File') ) {
      _smarty_error('no_class');
      $ok = FALSE;
    }
  }
  
  return $ok;
}

/**
* @function _smarty_error
*
* Display a useful error message
*
* @param $error
*   Shorthand for the error description
*/
function _smarty_error($error='default') {
  $errors = array(
      'default'       => t('There is an unknown problem with the smarty API'),
      'no_class'      => t('The smarty API could not find Smarty.class.php for inclusion.') . $doclink,
      'not_writeable' => t('The smarty API cannot write to the compiled template cache.') . $doclink,
      'no_init'       => t('The smarty API cannot be loaded.'),
  );
  if ( isset($errors[$error]) ) {
    $msg = $errors[$error];
  } else {
    $msg = $errors['default'];
  }
  session_set_message($msg, 'error');
}


/**
 * @function smarty_get_object
 *
 * Singleton generator. A singleton Smarty object is used to save resources
 * re-registering plugins, and to enable 'global' variables to be passed
 * between Smarty templates like {global var=myvar value=$localvar} which
 * can then be accessed as {$global.myvar}
 */
function _smarty_get_object() {
  static $smarty;

  if ( !isset($smarty) ) {
    _smarty_init();
    
    $smarty = new Sugar();
    $smarty->cache = new Sugar_Cache_File($smarty);
    $smarty->templateDir = realpath('./');
    $smarty->cacheDir  = __DIR__ .'/cache';
     
    // allow overloading of plugin file so look in the lowest level first
    $smarty->pluginDir  =  __DIR__.'/plugins';
    
    $smarty->output = Sugar::OUTPUT_TEXT;
    
    $smarty->debug = TRUE;

    // build list of standard plugins
    $plugins = array(
        'functions' => array(            
            'date_parse'=> '_smarty_function_date_parse', //add@byron
            
        ),
        'modifiers' => array(
            't' => '_smarty_modifier_t',
        	'convert_bytes'=> '_smarty_mofifier_convert_bytes'
        ),
    );
     
    foreach ( $plugins['modifiers'] as $key=>$value ) {
      if ( is_numeric($key) ) {
        $key = $value; // handle single parameter
      }
      // register the plugin
      $smarty->addModifier($key, $value);
    }

    foreach ( $plugins['functions'] as $key=>$value ) {
      if ( is_numeric($key) ) {
        $key = $value; // handle single parameter
      }
      // register the plugin
      $smarty->addFunction($key, $value);
    }
  }
  return $smarty;
}




/*++
 *+ @name date_parse
 *+ @param string $format The format to use, from the PHP date() function. (default 'r')
 *+ @return Returns associative array with detailed info about given date
 */
function _smarty_function_date_parse($sugar, $params){
  $time = Sugar_Util_GetArg($params, 'time', ''); 
  return date_parse($time);
}

function _smarty_modifier_t($sugar, $params){
	return call_user_func_array('text', $params);
}

function _smarty_mofifier_convert_bytes($sugar,$amount){
	$output = $amount;
	if ($amount> 1024*1024*1024){
		$output = number_format($amount/(1024*1024*1024),2) .'GB';
	}
	if ($amount> 1024*1024){
		$output = number_format($amount/(1024*1024),2) .'MB';
	}
	if ($amount> 1024){
		$output = number_format($amount/(1024),2) .'KB';
	}
	return $output;
}
