/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ignite.internal.processors.cache.transactions;

import org.apache.ignite.*;
import org.apache.ignite.internal.*;
import org.apache.ignite.internal.processors.cache.*;
import org.apache.ignite.internal.processors.cache.distributed.*;
import org.apache.ignite.internal.processors.cache.version.*;
import org.apache.ignite.internal.util.lang.*;
import org.apache.ignite.internal.util.tostring.*;
import org.apache.ignite.internal.util.typedef.*;
import org.apache.ignite.internal.util.typedef.internal.*;
import org.apache.ignite.plugin.extensions.communication.*;
import org.jetbrains.annotations.*;

import javax.cache.expiry.*;
import javax.cache.processor.*;
import java.io.*;
import java.nio.*;
import java.util.*;
import java.util.concurrent.atomic.*;

import static org.apache.ignite.internal.processors.cache.GridCacheOperation.*;
import static org.apache.ignite.internal.processors.cache.GridCacheUtils.*;

/**
 * Transaction entry. Note that it is essential that this class does not override
 * {@link #equals(Object)} method, as transaction entries should use referential
 * equality.
 */
@IgniteCodeGeneratingFail // Field filters should not be generated by MessageCodeGenerator.
public class IgniteTxEntry implements GridPeerDeployAware, Message {
    /** */
    private static final long serialVersionUID = 0L;

    /** Owning transaction. */
    @GridToStringExclude
    @GridDirectTransient
    private IgniteInternalTx tx;

    /** Cache key. */
    @GridToStringInclude
    private KeyCacheObject key;

    /** Cache ID. */
    private int cacheId;

    /** Transient tx key. */
    @GridDirectTransient
    private IgniteTxKey txKey;

    /** Cache value. */
    @GridToStringInclude
    private TxEntryValueHolder val = new TxEntryValueHolder();

    /** Visible value for peek. */
    @GridToStringInclude
    @GridDirectTransient
    private TxEntryValueHolder prevVal = new TxEntryValueHolder();

    /** Transform. */
    @GridToStringInclude
    @GridDirectTransient
    private Collection<T2<EntryProcessor<Object, Object, Object>, Object[]>> entryProcessorsCol;

    /** Transform closure bytes. */
    @GridToStringExclude
    private byte[] transformClosBytes;

    /** Time to live. */
    private long ttl;

    /** DR expire time (explicit) */
    private long conflictExpireTime = CU.EXPIRE_TIME_CALCULATE;

    /** Conflict version. */
    private GridCacheVersion conflictVer;

    /** Explicit lock version if there is one. */
    @GridToStringInclude
    private GridCacheVersion explicitVer;

    /** DHT version. */
    @GridDirectTransient
    private volatile GridCacheVersion dhtVer;

    /** Put filters. */
    @GridToStringInclude
    private CacheEntryPredicate[] filters;

    /** Flag indicating whether filters passed. Used for fast-commit transactions. */
    @GridDirectTransient
    private boolean filtersPassed;

    /** Flag indicating that filter is set and can not be replaced. */
    @GridDirectTransient
    private boolean filtersSet;

    /** Underlying cache entry. */
    @GridDirectTransient
    private volatile GridCacheEntryEx entry;

    /** Cache registry. */
    @GridDirectTransient
    private GridCacheContext<?, ?> ctx;

    /** Prepared flag to prevent multiple candidate add. */
    @SuppressWarnings({"TransientFieldNotInitialized"})
    @GridDirectTransient
    private AtomicBoolean prepared = new AtomicBoolean();

    /** Lock flag for collocated cache. */
    @GridDirectTransient
    private transient boolean locked;

    /** Assigned node ID (required only for partitioned cache). */
    @GridDirectTransient
    private UUID nodeId;

    /** Flag if this node is a back up node. */
    @GridDirectTransient
    private boolean locMapped;

    /** Expiry policy. */
    @GridDirectTransient
    private ExpiryPolicy expiryPlc;

    /** Expiry policy transfer flag. */
    @GridDirectTransient
    private boolean transferExpiryPlc;

    /** Expiry policy bytes. */
    private byte[] expiryPlcBytes;

    /**
     * Additional flags.
     * GridCacheUtils.SKIP_STORE_FLAG_MASK - for skipStore flag value.
     */
    private byte flags;

    /**
     * Required by {@link Externalizable}
     */
    public IgniteTxEntry() {
        /* No-op. */
    }

    /**
     * This constructor is meant for remote transactions.
     *
     * @param ctx Cache registry.
     * @param tx Owning transaction.
     * @param op Operation.
     * @param val Value.
     * @param ttl Time to live.
     * @param conflictExpireTime DR expire time.
     * @param entry Cache entry.
     * @param conflictVer Data center replication version.
     * @param skipStore Skip store flag.
     */
    public IgniteTxEntry(GridCacheContext<?, ?> ctx,
        IgniteInternalTx tx,
        GridCacheOperation op,
        CacheObject val,
        long ttl,
        long conflictExpireTime,
        GridCacheEntryEx entry,
        @Nullable GridCacheVersion conflictVer,
        boolean skipStore) {
        assert ctx != null;
        assert tx != null;
        assert op != null;
        assert entry != null;

        this.ctx = ctx;
        this.tx = tx;
        this.val.value(op, val, false, false);
        this.entry = entry;
        this.ttl = ttl;
        this.conflictExpireTime = conflictExpireTime;
        this.conflictVer = conflictVer;

        skipStore(skipStore);

        key = entry.key();

        cacheId = entry.context().cacheId();
    }

     /**
     * This constructor is meant for local transactions.
     *
     * @param ctx Cache registry.
     * @param tx Owning transaction.
     * @param op Operation.
     * @param val Value.
     * @param entryProcessor Entry processor.
     * @param invokeArgs Optional arguments for EntryProcessor.
     * @param ttl Time to live.
     * @param entry Cache entry.
     * @param filters Put filters.
     * @param conflictVer Data center replication version.
     * @param skipStore Skip store flag.
     */
    public IgniteTxEntry(GridCacheContext<?, ?> ctx,
        IgniteInternalTx tx,
        GridCacheOperation op,
        CacheObject val,
        EntryProcessor<Object, Object, Object> entryProcessor,
        Object[] invokeArgs,
        long ttl,
        GridCacheEntryEx entry,
        CacheEntryPredicate[] filters,
        GridCacheVersion conflictVer,
        boolean skipStore) {
        assert ctx != null;
        assert tx != null;
        assert op != null;
        assert entry != null;

        this.ctx = ctx;
        this.tx = tx;
        this.val.value(op, val, false, false);
        this.entry = entry;
        this.ttl = ttl;
        this.filters = filters;
        this.conflictVer = conflictVer;

        skipStore(skipStore);

        if (entryProcessor != null)
            addEntryProcessor(entryProcessor, invokeArgs);

        key = entry.key();

        cacheId = entry.context().cacheId();
    }

    /**
     * @return Cache context for this tx entry.
     */
    public GridCacheContext<?, ?> context() {
        return ctx;
    }

    /**
     * @return Flag indicating if this entry is affinity mapped to the same node.
     */
    public boolean locallyMapped() {
        return locMapped;
    }

    /**
     * @param locMapped Flag indicating if this entry is affinity mapped to the same node.
     */
    public void locallyMapped(boolean locMapped) {
        this.locMapped = locMapped;
    }

    /**
     * @param ctx Context.
     * @return Clean copy of this entry.
     */
    public IgniteTxEntry cleanCopy(GridCacheContext<?, ?> ctx) {
        IgniteTxEntry cp = new IgniteTxEntry();

        cp.key = key;
        cp.cacheId = cacheId;
        cp.ctx = ctx;

        cp.val = new TxEntryValueHolder();

        cp.filters = filters;
        cp.val.value(val.op(), val.value(), val.hasWriteValue(), val.hasReadValue());
        cp.entryProcessorsCol = entryProcessorsCol;
        cp.ttl = ttl;
        cp.conflictExpireTime = conflictExpireTime;
        cp.explicitVer = explicitVer;
        cp.conflictVer = conflictVer;
        cp.expiryPlc = expiryPlc;
        cp.flags = flags;

        return cp;
    }

    /**
     * @return Node ID.
     */
    public UUID nodeId() {
        return nodeId;
    }

    /**
     * @param nodeId Node ID.
     */
    public void nodeId(UUID nodeId) {
        this.nodeId = nodeId;
    }

    /**
     * @return DHT version.
     */
    public GridCacheVersion dhtVersion() {
        return dhtVer;
    }

    /**
     * @param dhtVer DHT version.
     */
    public void dhtVersion(GridCacheVersion dhtVer) {
        this.dhtVer = dhtVer;
    }

    /**
     * @return {@code True} if tx entry was marked as locked.
     */
    public boolean locked() {
        return locked;
    }

    /**
     * Marks tx entry as locked.
     */
    public void markLocked() {
        locked = true;
    }

    /**
     * @param val Value to set.
     */
    void setAndMarkValid(CacheObject val) {
        setAndMarkValid(op(), val, this.val.hasWriteValue(), this.val.hasReadValue());
    }

    /**
     * @param op Operation.
     * @param val Value to set.
     */
    void setAndMarkValid(GridCacheOperation op, CacheObject val) {
        setAndMarkValid(op, val, this.val.hasWriteValue(), this.val.hasReadValue());
    }

    /**
     * @param op Operation.
     * @param val Value to set.
     * @param hasReadVal Has read value flag.
     * @param hasWriteVal Has write value flag.
     */
    void setAndMarkValid(GridCacheOperation op, CacheObject val, boolean hasWriteVal, boolean hasReadVal) {
        this.val.value(op, val, hasWriteVal, hasReadVal);

        markValid();
    }

    /**
     * Marks this entry as value-has-bean-read. Effectively, makes values enlisted to transaction visible
     * to further peek operations.
     */
    void markValid() {
        prevVal.value(val.op(), val.value(), val.hasWriteValue(), val.hasReadValue());
    }

    /**
     * Marks entry as prepared.
     *
     * @return True if entry was marked prepared by this call.
     */
    boolean markPrepared() {
        return prepared.compareAndSet(false, true);
    }

    /**
     * @return Entry key.
     */
    public KeyCacheObject key() {
        return key;
    }

    /**
     * @return Cache ID.
     */
    public int cacheId() {
        return cacheId;
    }

    /**
     * Sets skip store flag value.
     *
     * @param skipStore Skip store flag.
     */
    public void skipStore(boolean skipStore){
        flags = skipStore ? (byte)(flags | SKIP_STORE_FLAG_MASK) : (byte)(flags & ~SKIP_STORE_FLAG_MASK);
    }

    /**
     * @return Skip store flag.
     */
    public boolean skipStore() {
        return (flags & SKIP_STORE_FLAG_MASK) == 1;
    }

    /**
     * @return Tx key.
     */
    public IgniteTxKey txKey() {
        if (txKey == null)
            txKey = new IgniteTxKey(key, cacheId);

        return txKey;
    }

    /**
     * @return Underlying cache entry.
     */
    public GridCacheEntryEx cached() {
        return entry;
    }

    /**
     * @param entry Cache entry.
     */
    public void cached(GridCacheEntryEx entry) {
        assert entry != null;

        assert entry.context() == ctx : "Invalid entry assigned to tx entry [txEntry=" + this +
            ", entry=" + entry + ", ctxNear=" + ctx.isNear() + ", ctxDht=" + ctx.isDht() + ']';

        this.entry = entry;
    }

    /**
     * @return Entry value.
     */
    @Nullable public CacheObject value() {
        return val.value();
    }

    /**
     * @return {@code True} if has value explicitly set.
     */
    public boolean hasValue() {
        return val.hasValue();
    }

    /**
     * @return {@code True} if has write value set.
     */
    public boolean hasWriteValue() {
        return val.hasWriteValue();
    }

    /**
     * @return {@code True} if has read value set.
     */
    public boolean hasReadValue() {
        return val.hasReadValue();
    }

    /**
     * @return Value visible for peek.
     */
    @Nullable public CacheObject previousValue() {
        return prevVal.value();
    }

    /**
     * @return {@code True} if has previous value explicitly set.
     */
    boolean hasPreviousValue() {
        return prevVal.hasValue();
    }

    /**
     * @return Previous operation to revert entry in case of filter failure.
     */
    @Nullable public GridCacheOperation previousOperation() {
        return prevVal.op();
    }

    /**
     * @return Time to live.
     */
    public long ttl() {
        return ttl;
    }

    /**
     * @param ttl Time to live.
     */
    public void ttl(long ttl) {
        this.ttl = ttl;
    }

    /**
     * @return Conflict expire time.
     */
    public long conflictExpireTime() {
        return conflictExpireTime;
    }

    /**
     * @param conflictExpireTime Conflict expire time.
     */
    public void conflictExpireTime(long conflictExpireTime) {
        this.conflictExpireTime = conflictExpireTime;
    }

    /**
     * @param val Entry value.
     * @param writeVal Write value flag.
     * @param readVal Read value flag.
     */
    public void value(@Nullable CacheObject val, boolean writeVal, boolean readVal) {
        this.val.value(this.val.op(), val, writeVal, readVal);
    }

    /**
     * Sets read value if this tx entry does not have write value yet.
     *
     * @param val Read value to set.
     */
    public void readValue(@Nullable CacheObject val) {
        this.val.value(this.val.op(), val, false, true);
    }

    /**
     * @param entryProcessor Entry processor.
     * @param invokeArgs Optional arguments for EntryProcessor.
     */
    public void addEntryProcessor(EntryProcessor<Object, Object, Object> entryProcessor, Object[] invokeArgs) {
        if (entryProcessorsCol == null)
            entryProcessorsCol = new LinkedList<>();

        entryProcessorsCol.add(new T2<>(entryProcessor, invokeArgs));

        // Must clear transform closure bytes since collection has changed.
        transformClosBytes = null;

        val.op(TRANSFORM);
    }

    /**
     * @return Collection of entry processors.
     */
    public Collection<T2<EntryProcessor<Object, Object, Object>, Object[]>> entryProcessors() {
        return entryProcessorsCol;
    }

    /**
     * @param cacheVal Value.
     * @return New value.
     */
    @SuppressWarnings("unchecked")
    public CacheObject applyEntryProcessors(CacheObject cacheVal) {
        Object val = null;
        Object keyVal = null;

        GridCacheVersion ver;

        try {
            ver = entry.version();
        }
        catch (GridCacheEntryRemovedException e) {
            assert tx == null || tx.optimistic() : tx;

            ver = null;
        }

        for (T2<EntryProcessor<Object, Object, Object>, Object[]> t : entryProcessors()) {
            try {
                CacheInvokeEntry<Object, Object> invokeEntry = new CacheInvokeEntry(ctx, key, keyVal, cacheVal, val,
                    ver);

                EntryProcessor processor = t.get1();

                processor.process(invokeEntry, t.get2());

                val = invokeEntry.getValue();

                keyVal = invokeEntry.key();
            }
            catch (Exception ignore) {
                // No-op.
            }
        }

        return ctx.toCacheObject(val);
    }

    /**
     * @param entryProcessorsCol Collection of entry processors.
     */
    public void entryProcessors(
        @Nullable Collection<T2<EntryProcessor<Object, Object, Object>, Object[]>> entryProcessorsCol) {
        this.entryProcessorsCol = entryProcessorsCol;

        // Must clear transform closure bytes since collection has changed.
        transformClosBytes = null;
    }

    /**
     * @return Cache operation.
     */
    public GridCacheOperation op() {
        return val.op();
    }

    /**
     * @param op Cache operation.
     */
    public void op(GridCacheOperation op) {
        val.op(op);
    }

    /**
     * @return {@code True} if read entry.
     */
    public boolean isRead() {
        return op() == READ;
    }

    /**
     * @param explicitVer Explicit version.
     */
    public void explicitVersion(GridCacheVersion explicitVer) {
        this.explicitVer = explicitVer;
    }

    /**
     * @return Explicit version.
     */
    public GridCacheVersion explicitVersion() {
        return explicitVer;
    }

    /**
     * @return Conflict version.
     */
    @Nullable public GridCacheVersion conflictVersion() {
        return conflictVer;
    }

    /**
     * @param conflictVer Conflict version.
     */
    public void conflictVersion(@Nullable GridCacheVersion conflictVer) {
        this.conflictVer = conflictVer;
    }

    /**
     * @return Put filters.
     */
    public CacheEntryPredicate[] filters() {
        return filters;
    }

    /**
     * @param filters Put filters.
     */
    public void filters(CacheEntryPredicate[] filters) {
        this.filters = filters;
    }

    /**
     * @return {@code True} if filters passed for fast-commit transactions.
     */
    public boolean filtersPassed() {
        return filtersPassed;
    }

    /**
     * @param filtersPassed {@code True} if filters passed for fast-commit transactions.
     */
    public void filtersPassed(boolean filtersPassed) {
        this.filtersPassed = filtersPassed;
    }

    /**
     * @return {@code True} if filters are set.
     */
    public boolean filtersSet() {
        return filtersSet;
    }

    /**
     * @param filtersSet {@code True} if filters are set and should not be replaced.
     */
    public void filtersSet(boolean filtersSet) {
        this.filtersSet = filtersSet;
    }

    /**
     * @param ctx Context.
     * @param transferExpiry {@code True} if expire policy should be marshalled.
     * @throws IgniteCheckedException If failed.
     */
    public void marshal(GridCacheSharedContext<?, ?> ctx, boolean transferExpiry) throws IgniteCheckedException {
        if (filters != null) {
            for (CacheEntryPredicate p : filters) {
                if (p != null)
                    p.prepareMarshal(ctx.cacheContext(cacheId));
            }
        }

        // Do not serialize filters if they are null.
        if (transformClosBytes == null && entryProcessorsCol != null)
            transformClosBytes = CU.marshal(ctx, entryProcessorsCol);

        if (transferExpiry)
            transferExpiryPlc = expiryPlc != null && expiryPlc != this.ctx.expiry();

        key.prepareMarshal(context().cacheObjectContext());

        val.marshal(ctx, context());

        expiryPlcBytes = transferExpiryPlc ?  CU.marshal(ctx, new IgniteExternalizableExpiryPolicy(expiryPlc)) : null;
    }

    /**
     * Unmarshalls entry.
     *
     * @param ctx Cache context.
     * @param near Near flag.
     * @param clsLdr Class loader.
     * @throws IgniteCheckedException If un-marshalling failed.
     */
    public void unmarshal(GridCacheSharedContext<?, ?> ctx, boolean near, ClassLoader clsLdr) throws IgniteCheckedException {
        if (this.ctx == null) {
            GridCacheContext<?, ?> cacheCtx = ctx.cacheContext(cacheId);

            if (cacheCtx.isNear() && !near)
                cacheCtx = cacheCtx.near().dht().context();
            else if (!cacheCtx.isNear() && near)
                cacheCtx = cacheCtx.dht().near().context();

            this.ctx = cacheCtx;
        }

        // Unmarshal transform closure anyway if it exists.
        if (transformClosBytes != null && entryProcessorsCol == null)
            entryProcessorsCol = ctx.marshaller().unmarshal(transformClosBytes, clsLdr);

        if (filters == null)
            filters = CU.empty0();
        else {
            for (CacheEntryPredicate p : filters) {
                if (p != null)
                    p.finishUnmarshal(ctx.cacheContext(cacheId), clsLdr);
            }
        }

        key.finishUnmarshal(context().cacheObjectContext(), clsLdr);

        val.unmarshal(this.ctx, clsLdr);

        if (expiryPlcBytes != null)
            expiryPlc =  ctx.marshaller().unmarshal(expiryPlcBytes, clsLdr);
    }

    /**
     * @param expiryPlc Expiry policy.
     */
    public void expiry(@Nullable ExpiryPolicy expiryPlc) {
        this.expiryPlc = expiryPlc;
    }

    /**
     * @return Expiry policy.
     */
    @Nullable public ExpiryPolicy expiry() {
        return expiryPlc;
    }

    /** {@inheritDoc} */
    @Override public boolean writeTo(ByteBuffer buf, MessageWriter writer) {
        writer.setBuffer(buf);

        if (!writer.isHeaderWritten()) {
            if (!writer.writeHeader(directType(), fieldsCount()))
                return false;

            writer.onHeaderWritten();
        }

        switch (writer.state()) {
            case 0:
                if (!writer.writeInt("cacheId", cacheId))
                    return false;

                writer.incrementState();

            case 1:
                if (!writer.writeLong("conflictExpireTime", conflictExpireTime))
                    return false;

                writer.incrementState();

            case 2:
                if (!writer.writeMessage("conflictVer", conflictVer))
                    return false;

                writer.incrementState();

            case 3:
                if (!writer.writeByteArray("expiryPlcBytes", expiryPlcBytes))
                    return false;

                writer.incrementState();

            case 4:
                if (!writer.writeMessage("explicitVer", explicitVer))
                    return false;

                writer.incrementState();

            case 5:
                if (!writer.writeObjectArray("filters",
                    !F.isEmptyOrNulls(filters) ? filters : null, MessageCollectionItemType.MSG))
                    return false;

                writer.incrementState();

            case 6:
                if (!writer.writeByte("flags", flags))
                    return false;

                writer.incrementState();

            case 7:
                if (!writer.writeMessage("key", key))
                    return false;

                writer.incrementState();

            case 8:
                if (!writer.writeByteArray("transformClosBytes", transformClosBytes))
                    return false;

                writer.incrementState();

            case 9:
                if (!writer.writeLong("ttl", ttl))
                    return false;

                writer.incrementState();

            case 10:
                if (!writer.writeMessage("val", val))
                    return false;

                writer.incrementState();

        }

        return true;
    }

    /** {@inheritDoc} */
    @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {
        reader.setBuffer(buf);

        if (!reader.beforeMessageRead())
            return false;

        switch (reader.state()) {
            case 0:
                cacheId = reader.readInt("cacheId");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 1:
                conflictExpireTime = reader.readLong("conflictExpireTime");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 2:
                conflictVer = reader.readMessage("conflictVer");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 3:
                expiryPlcBytes = reader.readByteArray("expiryPlcBytes");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 4:
                explicitVer = reader.readMessage("explicitVer");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 5:
                filters = reader.readObjectArray("filters", MessageCollectionItemType.MSG, CacheEntryPredicate.class);

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 6:
                flags = reader.readByte("flags");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 7:
                key = reader.readMessage("key");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 8:
                transformClosBytes = reader.readByteArray("transformClosBytes");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 9:
                ttl = reader.readLong("ttl");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

            case 10:
                val = reader.readMessage("val");

                if (!reader.isLastRead())
                    return false;

                reader.incrementState();

        }

        return true;
    }

    /** {@inheritDoc} */
    @Override public byte directType() {
        return 100;
    }

    /** {@inheritDoc} */
    @Override public byte fieldsCount() {
        return 11;
    }

    /** {@inheritDoc} */
    @Override public Class<?> deployClass() {
        ClassLoader clsLdr = getClass().getClassLoader();

        CacheObject val = value();

        // First of all check classes that may be loaded by class loader other than application one.
        return key != null && !clsLdr.equals(key.getClass().getClassLoader()) ?
            key.getClass() : val != null ? val.getClass() : getClass();
    }

    /** {@inheritDoc} */
    @Override public ClassLoader classLoader() {
        return deployClass().getClassLoader();
    }

    /** {@inheritDoc} */
    @Override public String toString() {
        return GridToStringBuilder.toString(IgniteTxEntry.class, this, "xidVer", tx == null ? "null" : tx.xidVersion());
    }

}
