/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ignite.schema.test.model;

import java.sql.*;
import java.util.*;

import org.apache.ignite.cache.*;
import org.apache.ignite.cache.store.jdbc.*;
import org.apache.ignite.configuration.*;

/**
 * CacheConfig definition.
 *
 * Code generated by Apache Ignite Schema Import utility: 08/18/2016.
 */
public class CacheConfig {
    /**
     * Create JDBC type for OBJECTS.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeObjects(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("PUBLIC");
        jdbcType.setDatabaseTable("OBJECTS");
        jdbcType.setKeyType("org.apache.ignite.schema.test.model.ObjectsKey");
        jdbcType.setValueType("org.apache.ignite.schema.test.model.Objects");

        // Key fields for OBJECTS.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "PK", int.class, "pk"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for OBJECTS.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "PK", int.class, "pk"));
        vals.add(new JdbcTypeField(Types.BOOLEAN, "BOOLCOL", Boolean.class, "boolcol"));
        vals.add(new JdbcTypeField(Types.TINYINT, "BYTECOL", Byte.class, "bytecol"));
        vals.add(new JdbcTypeField(Types.SMALLINT, "SHORTCOL", Short.class, "shortcol"));
        vals.add(new JdbcTypeField(Types.INTEGER, "INTCOL", Integer.class, "intcol"));
        vals.add(new JdbcTypeField(Types.BIGINT, "LONGCOL", Long.class, "longcol"));
        vals.add(new JdbcTypeField(Types.REAL, "FLOATCOL", Float.class, "floatcol"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "DOUBLECOL", Double.class, "doublecol"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "DOUBLECOL2", Double.class, "doublecol2"));
        vals.add(new JdbcTypeField(Types.DECIMAL, "BIGDECIMALCOL", java.math.BigDecimal.class, "bigdecimalcol"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "STRCOL", String.class, "strcol"));
        vals.add(new JdbcTypeField(Types.DATE, "DATECOL", java.sql.Date.class, "datecol"));
        vals.add(new JdbcTypeField(Types.TIME, "TIMECOL", java.sql.Time.class, "timecol"));
        vals.add(new JdbcTypeField(Types.TIMESTAMP, "TSCOL", java.sql.Timestamp.class, "tscol"));
        vals.add(new JdbcTypeField(Types.VARBINARY, "ARRCOL", Object.class, "arrcol"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "FIELD_WITH_ALIAS", String.class, "fieldWithAlias"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for OBJECTS.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityObjects() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.apache.ignite.schema.test.model.ObjectsKey");
        qryEntity.setValueType("org.apache.ignite.schema.test.model.Objects");

        // Query fields for OBJECTS.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("pk", "java.lang.Integer");
        fields.put("boolcol", "java.lang.Boolean");
        fields.put("bytecol", "java.lang.Byte");
        fields.put("shortcol", "java.lang.Short");
        fields.put("intcol", "java.lang.Integer");
        fields.put("longcol", "java.lang.Long");
        fields.put("floatcol", "java.lang.Float");
        fields.put("doublecol", "java.lang.Double");
        fields.put("doublecol2", "java.lang.Double");
        fields.put("bigdecimalcol", "java.math.BigDecimal");
        fields.put("strcol", "java.lang.String");
        fields.put("datecol", "java.sql.Date");
        fields.put("timecol", "java.sql.Time");
        fields.put("tscol", "java.sql.Timestamp");
        fields.put("arrcol", "java.lang.Object");
        fields.put("fieldWithAlias", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("fieldWithAlias", "FIELD_WITH_ALIAS");

        qryEntity.setAliases(aliases);

        // Indexes for OBJECTS.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("pk", true, "PRIMARY_KEY_C"));

        QueryIndex idx = new QueryIndex();

        idx.setName("IDX_1");

        idx.setIndexType(QueryIndexType.SORTED);

        LinkedHashMap<String, Boolean> idxFlds = new LinkedHashMap<>();

        idxFlds.put("intcol", true);
        idxFlds.put("longcol", true);

        idx.setFields(idxFlds);

        idxs.add(idx);

        idx = new QueryIndex();

        idx.setName("IDX_2");

        idx.setIndexType(QueryIndexType.SORTED);

        idxFlds = new LinkedHashMap<>();

        idxFlds.put("intcol", true);
        idxFlds.put("longcol", false);

        idx.setFields(idxFlds);

        idxs.add(idx);

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for PRIMITIVES.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypePrimitives(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("PUBLIC");
        jdbcType.setDatabaseTable("PRIMITIVES");
        jdbcType.setKeyType("org.apache.ignite.schema.test.model.PrimitivesKey");
        jdbcType.setValueType("org.apache.ignite.schema.test.model.Primitives");

        // Key fields for PRIMITIVES.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "PK", int.class, "pk"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for PRIMITIVES.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "PK", int.class, "pk"));
        vals.add(new JdbcTypeField(Types.BOOLEAN, "BOOLCOL", boolean.class, "boolcol"));
        vals.add(new JdbcTypeField(Types.TINYINT, "BYTECOL", byte.class, "bytecol"));
        vals.add(new JdbcTypeField(Types.SMALLINT, "SHORTCOL", short.class, "shortcol"));
        vals.add(new JdbcTypeField(Types.INTEGER, "INTCOL", int.class, "intcol"));
        vals.add(new JdbcTypeField(Types.BIGINT, "LONGCOL", long.class, "longcol"));
        vals.add(new JdbcTypeField(Types.REAL, "FLOATCOL", float.class, "floatcol"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "DOUBLECOL", double.class, "doublecol"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "DOUBLECOL2", double.class, "doublecol2"));
        vals.add(new JdbcTypeField(Types.DECIMAL, "BIGDECIMALCOL", java.math.BigDecimal.class, "bigdecimalcol"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "STRCOL", String.class, "strcol"));
        vals.add(new JdbcTypeField(Types.DATE, "DATECOL", java.sql.Date.class, "datecol"));
        vals.add(new JdbcTypeField(Types.TIME, "TIMECOL", java.sql.Time.class, "timecol"));
        vals.add(new JdbcTypeField(Types.TIMESTAMP, "TSCOL", java.sql.Timestamp.class, "tscol"));
        vals.add(new JdbcTypeField(Types.VARBINARY, "ARRCOL", Object.class, "arrcol"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "FIELD_WITH_ALIAS", String.class, "fieldWithAlias"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for PRIMITIVES.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityPrimitives() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.apache.ignite.schema.test.model.PrimitivesKey");
        qryEntity.setValueType("org.apache.ignite.schema.test.model.Primitives");

        // Query fields for PRIMITIVES.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("pk", "java.lang.Integer");
        fields.put("boolcol", "java.lang.Boolean");
        fields.put("bytecol", "java.lang.Byte");
        fields.put("shortcol", "java.lang.Short");
        fields.put("intcol", "java.lang.Integer");
        fields.put("longcol", "java.lang.Long");
        fields.put("floatcol", "java.lang.Float");
        fields.put("doublecol", "java.lang.Double");
        fields.put("doublecol2", "java.lang.Double");
        fields.put("bigdecimalcol", "java.math.BigDecimal");
        fields.put("strcol", "java.lang.String");
        fields.put("datecol", "java.sql.Date");
        fields.put("timecol", "java.sql.Time");
        fields.put("tscol", "java.sql.Timestamp");
        fields.put("arrcol", "java.lang.Object");
        fields.put("fieldWithAlias", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("fieldWithAlias", "FIELD_WITH_ALIAS");

        qryEntity.setAliases(aliases);

        // Indexes for PRIMITIVES.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("pk", true, "PRIMARY_KEY_D"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for TST.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeTst(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("TESTSCHEMA");
        jdbcType.setDatabaseTable("TST");
        jdbcType.setKeyType("org.apache.ignite.schema.test.model.TstKey");
        jdbcType.setValueType("org.apache.ignite.schema.test.model.Tst");

        // Key fields for TST.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "PK", int.class, "pk"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for TST.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "PK", int.class, "pk"));
        vals.add(new JdbcTypeField(Types.BOOLEAN, "BOOLCOL", boolean.class, "boolcol"));
        vals.add(new JdbcTypeField(Types.TINYINT, "BYTECOL", byte.class, "bytecol"));
        vals.add(new JdbcTypeField(Types.SMALLINT, "SHORTCOL", short.class, "shortcol"));
        vals.add(new JdbcTypeField(Types.INTEGER, "INTCOL", int.class, "intcol"));
        vals.add(new JdbcTypeField(Types.BIGINT, "LONGCOL", long.class, "longcol"));
        vals.add(new JdbcTypeField(Types.REAL, "FLOATCOL", float.class, "floatcol"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "DOUBLECOL", double.class, "doublecol"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "DOUBLECOL2", double.class, "doublecol2"));
        vals.add(new JdbcTypeField(Types.DECIMAL, "BIGDECIMALCOL", java.math.BigDecimal.class, "bigdecimalcol"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "STRCOL", String.class, "strcol"));
        vals.add(new JdbcTypeField(Types.DATE, "DATECOL", java.sql.Date.class, "datecol"));
        vals.add(new JdbcTypeField(Types.TIME, "TIMECOL", java.sql.Time.class, "timecol"));
        vals.add(new JdbcTypeField(Types.TIMESTAMP, "TSCOL", java.sql.Timestamp.class, "tscol"));
        vals.add(new JdbcTypeField(Types.VARBINARY, "ARRCOL", Object.class, "arrcol"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "FIELD_WITH_ALIAS", String.class, "fieldWithAlias"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for TST.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityTst() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.apache.ignite.schema.test.model.TstKey");
        qryEntity.setValueType("org.apache.ignite.schema.test.model.Tst");

        // Query fields for TST.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("pk", "java.lang.Integer");
        fields.put("boolcol", "java.lang.Boolean");
        fields.put("bytecol", "java.lang.Byte");
        fields.put("shortcol", "java.lang.Short");
        fields.put("intcol", "java.lang.Integer");
        fields.put("longcol", "java.lang.Long");
        fields.put("floatcol", "java.lang.Float");
        fields.put("doublecol", "java.lang.Double");
        fields.put("doublecol2", "java.lang.Double");
        fields.put("bigdecimalcol", "java.math.BigDecimal");
        fields.put("strcol", "java.lang.String");
        fields.put("datecol", "java.sql.Date");
        fields.put("timecol", "java.sql.Time");
        fields.put("tscol", "java.sql.Timestamp");
        fields.put("arrcol", "java.lang.Object");
        fields.put("fieldWithAlias", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("fieldWithAlias", "FIELD_WITH_ALIAS");

        qryEntity.setAliases(aliases);

        // Indexes for TST.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("pk", true, "PRIMARY_KEY_1"));

        QueryIndex idx = new QueryIndex();

        idx.setName("IDX_3");

        idx.setIndexType(QueryIndexType.SORTED);

        LinkedHashMap<String, Boolean> idxFlds = new LinkedHashMap<>();

        idxFlds.put("intcol", true);
        idxFlds.put("longcol", true);

        idx.setFields(idxFlds);

        idxs.add(idx);

        idx = new QueryIndex();

        idx.setName("IDX_4");

        idx.setIndexType(QueryIndexType.SORTED);

        idxFlds = new LinkedHashMap<>();

        idxFlds.put("intcol", true);
        idxFlds.put("longcol", false);

        idx.setFields(idxFlds);

        idxs.add(idx);

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Configure cache.
     *
     * @param cacheName Cache name.
     * @param storeFactory Cache store factory.
     * @return Cache configuration.
     */
    public static <K, V> CacheConfiguration<K, V> cache(String cacheName, CacheJdbcPojoStoreFactory<K, V> storeFactory) {
        if (storeFactory == null)
             throw new IllegalArgumentException("Cache store factory cannot be null.");

        CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(cacheName);

        ccfg.setCacheStoreFactory(storeFactory);
        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        // Configure JDBC types.
        Collection<JdbcType> jdbcTypes = new ArrayList<>();

        jdbcTypes.add(jdbcTypeObjects(cacheName));
        jdbcTypes.add(jdbcTypePrimitives(cacheName));
        jdbcTypes.add(jdbcTypeTst(cacheName));

        storeFactory.setTypes(jdbcTypes.toArray(new JdbcType[jdbcTypes.size()]));

        // Configure query entities.
        Collection<QueryEntity> qryEntities = new ArrayList<>();

        qryEntities.add(queryEntityObjects());
        qryEntities.add(queryEntityPrimitives());
        qryEntities.add(queryEntityTst());

        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }
}
