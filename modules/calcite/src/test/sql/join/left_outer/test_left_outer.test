# name: test/sql/join/left_outer/test_left_outer.test
# description: Test LEFT OUTER JOIN
# group: [left_outer]

statement ok
PRAGMA enable_verification

statement ok
CREATE TABLE integers(ii INTEGER, jj INTEGER)

statement ok
INSERT INTO integers VALUES (1, 2), (2, 3), (3, 4)

statement ok
CREATE TABLE integers2(kk INTEGER, l INTEGER)

statement ok
INSERT INTO integers2 VALUES (1, 10), (2, 20)

query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.ii=integers2.kk ORDER BY ii
----
1	2	1	10
2	3	2	20
3	4	NULL	NULL

# RIGHT OUTER JOIN is just LEFT OUTER JOIN but with arguments reversed
# with one caveat: SELECT * will project the columns of the LHS first!
query IIII
SELECT * FROM integers2 RIGHT OUTER JOIN integers ON integers.ii=integers2.kk ORDER BY ii
----
1	10	1	2
2	20	2	3
NULL	NULL	3	4

# WHERE happens AFTER the join, thus [where kk IS NOT NULL] filters out any tuples with generated NULL values from
# the LEFT OUTER JOIN. Because of this, this join is equivalent to an inner join.
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.ii=integers2.kk  WHERE kk IS NOT NULL ORDER BY ii
----
1	2	1	10
2	3	2	20

# however, any conditions in the ON clause happen BEFORE the join, thus the condition [integers2.kk IS NOT NULL]
# happens BEFORE any NULL values are generated by the LEFT OUTER JOIN.
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.ii=integers2.kk AND integers2.kk IS NOT NULL ORDER BY ii
----
1	2	1	10
2	3	2	20
3	4	NULL	NULL

# filter on LHS
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON ii=1 ORDER BY ii, kk;
----
1	2	1	10
1	2	2	20
2	3	NULL	NULL
3	4	NULL	NULL

# left outer join on "true" is cross product
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON 1=1 ORDER BY ii, kk;
----
1	2	1	10
1	2	2	20
2	3	1	10
2	3	2	20
3	4	1	10
3	4	2	20

# except if RHS is empty; then it is the LHS with NULl values appended
query IIII
SELECT * FROM integers LEFT OUTER JOIN (SELECT * FROM integers2 WHERE 1<>1) tbl2 ON 1=2 ORDER BY ii;
----
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

# left outer join on "false" gives the LHS with the RHS filled as NULL
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON 1=2 ORDER BY ii;
----
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

# left outer join on NULL constant gives the LHS with the RHS filled as null as well
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON NULL<>NULL ORDER BY ii;
----
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

# left outer join on condition that only concerns the LHS
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON ii=1 ORDER BY ii, kk;
----
1	2	1	10
1	2	2	20
2	3	NULL	NULL
3	4	NULL	NULL

#  left outer join on condition that only concerns the RHS
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON l=20 ORDER BY ii, kk;
----
1	2	2	20
2	3	2	20
3	4	2	20

query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON l>0 ORDER BY ii, kk;
----
1	2	1	10
1	2	2	20
2	3	1	10
2	3	2	20
3	4	1	10
3	4	2	20

#  left outer join on condition that affects both, but is not aa simple comparison
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON ii=1 OR l=20 ORDER BY ii, kk;
----
1	2	1	10
1	2	2	20
2	3	2	20
3	4	2	20

query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON ii=4 OR l=17 ORDER BY ii;
----
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON ii+l=21 ORDER BY ii;
----
1	2	2	20
2	3	NULL	NULL
3	4	NULL	NULL

query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON ii+l>12 ORDER BY ii, kk;
----
1	2	2	20
2	3	2	20
3	4	1	10
3	4	2	20

# range join
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.ii<integers2.kk WHERE integers.ii <= 2 ORDER BY ii
----
1	2	2	20
2	3	NULL	NULL

# multiple conditions
query IIII
SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.ii<integers2.kk AND integers.ii<integers2.l WHERE integers.ii <= 2 ORDER BY ii
----
1	2	2	20
2	3	NULL	NULL

query IIII
SELECT * FROM integers LEFT OUTER JOIN (SELECT * FROM integers2 WHERE kk=100) integers2 ON integers.ii<integers2.kk ORDER BY ii
----
1	2	NULL	NULL
2	3	NULL	NULL
3	4	NULL	NULL

query II
select * from (values(1), (2)) t1(ii) left join (values (2), (3)) t2(ii) on t1.ii=t2.ii AND t1.ii+t2.ii=4 ORDER BY 1, 2;
----
1	NULL
2	2
