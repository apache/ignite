select 1000L / 10;
> 100;
select * from (select x as y from dual order by y);
> 1;
select a.x from dual a, dual b order by x;
> 1;
select 1 from(select 2 from(select 1) a right join dual b) c;
> 1;
select 1.00 / 3 * 0.00;
> 0.00000000000000000000000000000;
select 1.00000 / 3 * 0.0000;
> 0.0000000000000000000000000000000000;
select 1.0000000 / 3 * 0.00000;
> 0.0000000000000000000000000000000000000;
select 1.0000000 / 3 * 0.000000;
> 0E-38;
create table test(id null);
drop table test;
select * from (select group_concat(distinct 1) from system_range(1, 3));
> 1;
select sum(mod(x, 2) = 1) from system_range(1, 10);
> 5;
create table a(x int);
create table b(x int);
select count(*) from (select b.x from a left join b);
> 0;
drop table a, b;
select count(distinct now()) c from system_range(1, 100), system_range(1, 1000);
> 1;
select {fn TIMESTAMPADD(SQL_TSI_DAY, 1, {ts '2011-10-20 20:30:40.001'})};
> 2011-10-21 20:30:40.001;
select {fn TIMESTAMPADD(SQL_TSI_SECOND, 1, cast('2011-10-20 20:30:40.001' as timestamp))};
> 2011-10-20 20:30:41.001;
select N'test';
> test;
select E'test\\test';
> test\test;
create table a(id int) as select null;
create table b(id int references a(id)) as select null;
delete from a;
drop table a, b;
create table test(a int, b int) as select 2, 0;
create index idx on test(b, a);
select count(*) from test where a in(2, 10) and b in(0, null);
> 1;
drop table test;
create table test(a int, b int) as select 1, 0;
create index idx on test(b, a);
select count(*) from test where b in(null, 0) and a in(1, null);
> 1;
drop table test;
create cached temp table test(id identity) not persistent;
drop table test;
create table test(a int, b int, unique(a, b));
insert into test values(1,1), (1,2);
select count(*) from test where a in(1,2) and b in(1,2);
> 2;
drop table test;
create table test(id int);
alter table test alter column id set default 'x';
select column_default from information_schema.columns c where c.table_name = 'TEST' and c.column_name = 'ID';
> 'x';
alter table test alter column id set not null;
select is_nullable from information_schema.columns c where c.table_name = 'TEST' and c.column_name = 'ID';
> NO;
alter table test alter column id set data type varchar;
select type_name from information_schema.columns c where c.table_name = 'TEST' and c.column_name = 'ID';
> VARCHAR;
alter table test alter column id type int;
select type_name from information_schema.columns c where c.table_name = 'TEST' and c.column_name = 'ID';
> INTEGER;
alter table test alter column id drop default;
select column_default from information_schema.columns c where c.table_name = 'TEST' and c.column_name = 'ID';
> null;
alter table test alter column id drop not null;
select is_nullable from information_schema.columns c where c.table_name = 'TEST' and c.column_name = 'ID';
> YES;
drop table test;
select x from (select *, rownum as r from system_range(1, 3)) where r=2;
> 2;
create table test(name varchar(255)) as select 'Hello+World+';
select count(*) from test where name like 'Hello++World++' escape '+';
> 1;
select count(*) from test where name like '+H+e+l+l+o++World++' escape '+';
> 1;
select count(*) from test where name like 'Hello+World++' escape '+';
> 0;
select count(*) from test where name like 'Hello++World+' escape '+';
> 0;
drop table test;

select count(*) from system_range(1, 1);
> 1;
select count(*) from system_range(1, -1);
> 0;

select 1 from dual where '\' like '\' escape '';
> 1;
select left(timestamp '2001-02-03 08:20:31+04', 4);
> 2001;

create table t1$2(id int);
drop table t1$2;

create table test(id int primary key) as select x from system_range(1, 200);
delete from test;
insert into test(id) values(1);
select * from test order by id;
> 1;
drop table test;

create memory table test(id int) not persistent as select 1 from dual;
insert into test values(1);
select count(1) from test;
> 2;
@reconnect;
select count(1) from test;
> 0;
drop table test;
create table test(t clob) as select 1;
select distinct t from test;
> 1;
drop table test;
create table test(id int unique not null);
drop table test;
create table test(id int not null unique);
drop table test;
select count(*)from((select 1 from dual limit 1)union(select 2 from dual limit 1));
> 2;
select sum(cast(x as int)) from system_range(2147483547, 2147483637);
> 195421006872;
select sum(x) from system_range(9223372036854775707, 9223372036854775797);
> 839326855353784593432;
select sum(cast(100 as tinyint)) from system_range(1, 1000);
> 100000;
select sum(cast(100 as smallint)) from system_range(1, 1000);
> 100000;
select avg(cast(x as int)) from system_range(2147483547, 2147483637);
> 2147483592;
select avg(x) from system_range(9223372036854775707, 9223372036854775797);
> 9223372036854775752;
select avg(cast(100 as tinyint)) from system_range(1, 1000);
> 100;
select avg(cast(100 as smallint)) from system_range(1, 1000);
> 100;
select datediff(yyyy, now(), now());
> 0;
create table t(d date) as select '2008-11-01' union select '2008-11-02';
select 1 from t group by year(d) order by year(d);
> 1;
drop table t;
create table t(d int) as select 2001 union select 2002;
select 1 from t group by d/10 order by d/10;
> 1;
drop table t;

create schema test;
create sequence test.report_id_seq;
select nextval('"test".REPORT_ID_SEQ');
> 1;
select nextval('"test"."report_id_seq"');
> 2;
select nextval('test.report_id_seq');
> 3;
drop schema test cascade;

create table master(id int primary key);
create table detail(id int primary key, x bigint, foreign key(x) references master(id) on delete cascade);
alter table detail alter column x bigint;
insert into master values(0);
insert into detail values(0,0);
delete from master;
drop table master, detail;

drop all objects;
create table test(id int, parent int references test(id) on delete cascade);
insert into test values(0, 0);
alter table test rename to test2;
delete from test2;
drop table test2;

SELECT X FROM dual GROUP BY X HAVING X=AVG(X);
> 1;
create view test_view(id,) as select * from dual;
drop view test_view;
create table test(id int,);
insert into test(id,) values(1,);
merge into test(id,) key(id,) values(1,);
drop table test;

SET MODE DB2;
SELECT * FROM SYSTEM_RANGE(1, 100) OFFSET 99 ROWS;
> 100;
SELECT * FROM SYSTEM_RANGE(1, 100) OFFSET 50 ROWS FETCH FIRST 1 ROW ONLY;
> 51;
SELECT * FROM SYSTEM_RANGE(1, 100) FETCH FIRST 1 ROWS ONLY;
> 1;
SELECT * FROM SYSTEM_RANGE(1, 100) FETCH FIRST ROW ONLY;
> 1;
SET MODE REGULAR;

create domain email as varchar comment 'e-mail';
create table test(e email);
select remarks from INFORMATION_SCHEMA.COLUMNS where table_name='TEST';
> e-mail;
drop table test;
drop domain email;

create table test$test(id int);
drop table test$test;
create table test$$test(id int);
drop table test$$test;
create table test (id varchar(36) as random_uuid() primary key);
insert into test() values();
delete from test where id = select id from test;
drop table test;
create table test (id varchar(36) as now() primary key);
insert into test() values();
delete from test where id = select id from test;
drop table test;
SELECT SOME(X>4) FROM SYSTEM_RANGE(1,6);
> TRUE;
SELECT EVERY(X>4) FROM SYSTEM_RANGE(1,6);
> FALSE;
SELECT BOOL_OR(X>4) FROM SYSTEM_RANGE(1,6);
> TRUE;
SELECT BOOL_AND(X>4) FROM SYSTEM_RANGE(1,6);
> FALSE;
SELECT BIT_OR(X) FROM SYSTEM_RANGE(1,6);
> 7;
SELECT BIT_AND(X) FROM SYSTEM_RANGE(1,6);
> 0;
SELECT BIT_AND(X) FROM SYSTEM_RANGE(1,1);
> 1;
CREATE TABLE TEST(ID IDENTITY);
ALTER TABLE TEST ALTER COLUMN ID RESTART WITH ? {1:10};
INSERT INTO TEST VALUES(NULL);
SELECT * FROM TEST;
> 10;
DROP TABLE TEST;
CREATE SEQUENCE TEST_SEQ;
ALTER SEQUENCE TEST_SEQ RESTART WITH ? INCREMENT BY ? {1:20, 2: 3};
SELECT NEXT VALUE FOR TEST_SEQ;
> 20;
SELECT NEXT VALUE FOR TEST_SEQ;
> 23;
DROP SEQUENCE TEST_SEQ;

create schema Contact;
CREATE TABLE Account (id BIGINT);
CREATE TABLE Person (id BIGINT, FOREIGN KEY (id) REFERENCES Account(id));
CREATE TABLE Contact.Contact (id BIGINT, FOREIGN KEY (id) REFERENCES public.Person(id));
drop schema contact cascade;
drop table account, person;

create schema Contact;
CREATE TABLE Account (id BIGINT primary key);
CREATE TABLE Person (id BIGINT primary key, FOREIGN KEY (id) REFERENCES Account);
CREATE TABLE Contact.Contact (id BIGINT primary key, FOREIGN KEY (id) REFERENCES public.Person);
drop schema contact cascade;
drop table account, person;

CREATE TABLE TEST(A int NOT NULL, B int NOT NULL, C int) ;
ALTER TABLE TEST ADD CONSTRAINT CON UNIQUE(A,B);
ALTER TABLE TEST DROP C;
ALTER TABLE TEST DROP CONSTRAINT CON;
ALTER TABLE TEST DROP B;
DROP TABLE TEST;

select count(d.*) from dual d group by d.x;
> 1;

create table test(id int);
select count(*) from (select * from ((select * from test) union (select * from test)) a) b where id = 0;
> 0;
select count(*) from (select * from ((select * from test) union select * from test) a) b where id = 0;
> 0;
select count(*) from (select * from (select * from test union select * from test) a) b where id = 0;
> 0;
select 1 from ((test d1 inner join test d2 on d1.id = d2.id) inner join test d3 on d1.id = d3.id) inner join test d4 on d4.id = d1.id;
drop table test;

select lpad('string', 10);
>     string;

select count(*) from (select * from dual union select * from dual) where x = 0;
> 0;
select count(*) from (select * from (select * from dual union select * from dual)) where x = 0;
> 0;

select instr('abcisj','s', -1) from dual;
> 5;
CREATE TABLE TEST(ID INT);
INSERT INTO TEST VALUES(1), (2), (3);
create index idx_desc on test(id desc);
select * from test where id between 0 and 1;
> 1;
select * from test where id between 3 and 4;
> 3;
drop table test;

CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255));
INSERT INTO TEST VALUES(1, 'Hello'), (2, 'HelloWorld'), (3, 'HelloWorldWorld');
SELECT COUNT(*) FROM TEST WHERE NAME REGEXP 'World';
> 2;
SELECT NAME FROM TEST WHERE NAME REGEXP 'WorldW';
> HelloWorldWorld;
drop table test;

select * from (select x from (select x from dual)) where 1=x;
> 1;
CREATE VIEW TEST_VIEW AS SELECT X FROM (SELECT X FROM DUAL);
SELECT * FROM TEST_VIEW;
> 1;
SELECT * FROM TEST_VIEW;
> 1;
DROP VIEW TEST_VIEW;

SELECT X FROM (SELECT X, X AS "XY" FROM DUAL) WHERE X=1;
> 1;
SELECT X FROM (SELECT X, X AS "X Y" FROM DUAL) WHERE X=1;
> 1;
SELECT X FROM (SELECT X, X AS "X Y" FROM DUAL AS "D Z") WHERE X=1;
> 1;

select * from (select x from dual union select convert(x, int) from dual) where x=0;
create table test(id int);
insert into scriptSimple.public.test(id) values(1), (2);
update test t set t.id=t.id+1;
update public.test set public.test.id=1;
select count(scriptSimple.public.test.id) from scriptSimple.public.test;
> 2;
update scriptSimple.public.test set scriptSimple.public.test.id=1;
drop table scriptSimple.public.test;

select year(timestamp '2007-07-26T18:44:26.109000+02:00');
> 2007;

create table test(id int primary key);
begin;
insert into test values(1);
rollback;
insert into test values(2);
rollback;
begin;
insert into test values(3);
commit;
insert into test values(4);
rollback;
select group_concat(id order by id) from test;
> 2,3,4;
drop table test;

create table test();
insert into test values();
ALTER TABLE TEST ADD ID INTEGER;
select count(*) from test;
> 1;
drop table test;

select * from dual where 'a_z' like '%=_%' escape '=';
> 1;

create table test as select 1 from dual union all select 2 from dual;
drop table test;

create table test_table(column_a integer);
insert into test_table values(1);
create view test_view AS SELECT * FROM (SELECT DISTINCT * FROM test_table) AS subquery;
select * FROM test_view;
> 1;
drop view test_view;
drop table test_table;

CREATE TABLE TEST(ID INT);
INSERT INTO TEST VALUES(1);
CREATE VIEW TEST_VIEW AS SELECT COUNT(ID) X FROM TEST;
explain SELECT * FROM TEST_VIEW WHERE X>1;
DROP VIEW TEST_VIEW;
DROP TABLE TEST;

create table test1(id int);
insert into test1 values(1), (1), (2), (3);
select sum(C0) from (select count(*) AS C0 from (select distinct * from test1) as temp);
> 3;
drop table test1;

create table test(id int primary key check id>1);
drop table test;
create table table1(f1 int not null primary key);
create table table2(f2 int not null references table1(f1) on delete cascade);
drop table table2;
drop table table1;
create table table1(f1 int not null primary key);
create table table2(f2 int not null primary key references table1(f1));
drop table table1;
drop table table2;

select case when 1=null then 1 else 2 end;
> 2;

select case (1) when 1 then 1 else 2 end;
> 1;

create table test(id int);
insert into test values(1);
select distinct id from test a order by a.id;
> 1;
drop table test;

create table FOO (ID int, A number(18, 2));
insert into FOO (ID, A) values (1, 10.0), (2, 20.0);
select SUM (CASE when ID=1 then 0 ELSE A END) col0 from Foo;
> 20.00;
drop table FOO;

select (SELECT true)+1 GROUP BY 1;
> 2;
create table FOO (ID int, A number(18, 2));
insert into FOO (ID, A) values (1, 10.0), (2, 20.0);
select SUM (CASE when ID=1 then A ELSE 0 END) col0 from Foo;
> 10.00;
drop table FOO;

create table A ( ID integer,  a1 varchar(20) );
create table B ( ID integer,  AID integer,  b1 varchar(20));
create table C ( ID integer,  BId integer,  c1 varchar(20));
insert into A (ID, a1) values (1, 'a1');
insert into A (ID, a1) values (2, 'a2');
select count(*) from A left outer join (B  inner join C on C.BID=B.ID )  on B.AID=A.ID where A.id=1;
> 1;
select count(*) from A left outer join (B  left join C on C.BID=B.ID )  on B.AID=A.ID where A.id=1;
> 1;
select count(*) from A left outer join B on B.AID=A.ID inner join C on C.BID=B.ID where A.id=1;
> 0;
select count(*) from (A left outer join B on B.AID=A.ID) inner join C on C.BID=B.ID where A.id=1;
> 0;
drop table a, b, c;

create schema a;
create table a.test(id int);
insert into a.test values(1);
create schema b;
create table b.test(id int);
insert into b.test values(2);
select a.test.id + b.test.id from a.test, b.test;
> 3;
drop schema a cascade;
drop schema b cascade;

select date '+0011-01-01';
> 0011-01-01;
select date'-0010-01-01';
> -10-01-01;

create schema TEST_SCHEMA;
create table TEST_SCHEMA.test(id int);
create sequence TEST_SCHEMA.TEST_SEQ;
select TEST_SCHEMA.TEST_SEQ.CURRVAL;
> 0;
select TEST_SCHEMA.TEST_SEQ.nextval;
> 1;
drop schema TEST_SCHEMA cascade;

create table test(id int);
create trigger TEST_TRIGGER before insert on test call "org.h2.test.db.TestTriggersConstraints";
comment on trigger TEST_TRIGGER is 'just testing';
select remarks from information_schema.triggers where trigger_name = 'TEST_TRIGGER';
> just testing;
@reconnect;
select remarks from information_schema.triggers where trigger_name = 'TEST_TRIGGER';
> just testing;
drop trigger TEST_TRIGGER;
@reconnect;

create alias parse_long for "java.lang.Long.parseLong(java.lang.String)";
comment on alias parse_long is 'Parse a long with base';
select remarks from information_schema.function_aliases where alias_name = 'PARSE_LONG';
> Parse a long with base;
@reconnect;
select remarks from information_schema.function_aliases where alias_name = 'PARSE_LONG';
> Parse a long with base;
drop alias parse_long;
@reconnect;

create role hr;
comment on role hr is 'Human Resources';
select remarks from information_schema.roles where name = 'HR';
> Human Resources;
@reconnect;
select remarks from information_schema.roles where name = 'HR';
> Human Resources;
create user abc password 'x';
grant hr to abc;
drop role hr;
@reconnect;
drop user abc;

create domain email as varchar(100) check instr(value, '@') > 0;
comment on domain email is 'must contain @';
select remarks from information_schema.domains where domain_name = 'EMAIL';
> must contain @;
@reconnect;
select remarks from information_schema.domains where domain_name = 'EMAIL';
> must contain @;
drop domain email;
@reconnect;

create schema tests;
set schema tests;
create sequence walk;
comment on schema tests is 'Test Schema';
comment on sequence walk is 'Walker';
select remarks from information_schema.schemata where schema_name = 'TESTS';
> Test Schema;
select remarks from information_schema.sequences where sequence_name = 'WALK';
> Walker;
@reconnect;
select remarks from information_schema.schemata where schema_name = 'TESTS';
> Test Schema;
select remarks from information_schema.sequences where sequence_name = 'WALK';
> Walker;
drop schema tests cascade;
@reconnect;

create constant abc value 1;
comment on constant abc is 'One';
select remarks from information_schema.constants where constant_name = 'ABC';
> One;
@reconnect;
select remarks from information_schema.constants where constant_name = 'ABC';
> One;
drop constant abc;
drop table test;
@reconnect;

create table test(id int);
alter table test add constraint const1 unique(id);
create index IDX_ID on test(id);
comment on constraint const1 is 'unique id';
comment on index IDX_ID is 'id_index';
select remarks from information_schema.constraints where constraint_name = 'CONST1';
> unique id;
select remarks from information_schema.indexes where index_name = 'IDX_ID';
> id_index;
@reconnect;
select remarks from information_schema.constraints where constraint_name = 'CONST1';
> unique id;
select remarks from information_schema.indexes where index_name = 'IDX_ID';
> id_index;
drop table test;
@reconnect;

create user sales password '1';
comment on user sales is 'mr. money';
select remarks from information_schema.users where name = 'SALES';
> mr. money;
@reconnect;
select remarks from information_schema.users where name = 'SALES';
> mr. money;
alter user sales rename to SALES_USER;
select remarks from information_schema.users where name = 'SALES_USER';
> mr. money;
@reconnect;
select remarks from information_schema.users where name = 'SALES_USER';
> mr. money;

create table test(id int);
create linked table test_link('org.h2.Driver', 'jdbc:h2:mem:', 'sa', 'sa', 'DUAL');
comment on table test_link is '123';
select remarks from information_schema.tables where table_name = 'TEST_LINK';
> 123;
@reconnect;
select remarks from information_schema.tables where table_name = 'TEST_LINK';
> 123;
comment on table test_link is 'xyz';
select remarks from information_schema.tables where table_name = 'TEST_LINK';
> xyz;
alter table test_link rename to test_l;
select remarks from information_schema.tables where table_name = 'TEST_L';
> xyz;
@reconnect;
select remarks from information_schema.tables where table_name = 'TEST_L';
> xyz;
drop table test;
@reconnect;

create table test(id int);
create view test_v as select * from test;
comment on table test_v is 'abc';
select remarks from information_schema.tables where table_name = 'TEST_V';
> abc;
@reconnect;
select remarks from information_schema.tables where table_name = 'TEST_V';
> abc;
alter table test_v rename to TEST_VIEW;
select remarks from information_schema.tables where table_name = 'TEST_VIEW';
> abc;
@reconnect;
select remarks from information_schema.tables where table_name = 'TEST_VIEW';
> abc;
drop table test cascade;
@reconnect;

create table test(a int);
comment on table test is 'hi';
select remarks from information_schema.tables where table_name = 'TEST';
> hi;
alter table test add column b int;
select remarks from information_schema.tables where table_name = 'TEST';
> hi;
alter table test rename to test1;
select remarks from information_schema.tables where table_name = 'TEST1';
> hi;
@reconnect;
select remarks from information_schema.tables where table_name = 'TEST1';
> hi;
comment on table test1 is 'ho';
@reconnect;
select remarks from information_schema.tables where table_name = 'TEST1';
> ho;
drop table test1;

create table test(a int, b int);
comment on column test.b is 'test';
select remarks from information_schema.columns where table_name = 'TEST' and column_name = 'B';
> test;
@reconnect;
select remarks from information_schema.columns where table_name = 'TEST' and column_name = 'B';
> test;
alter table test drop column b;
@reconnect;
comment on column test.a is 'ho';
select remarks from information_schema.columns where table_name = 'TEST' and column_name = 'A';
> ho;
@reconnect;
select remarks from information_schema.columns where table_name = 'TEST' and column_name = 'A';
> ho;
drop table test;
@reconnect;

create table test(a int);
comment on column test.a is 'test';
alter table test rename to test2;
@reconnect;
select remarks from information_schema.columns where table_name = 'TEST2';
> test;
@reconnect;
select remarks from information_schema.columns where table_name = 'TEST2';
> test;
drop table test2;
@reconnect;

create table test1 (a varchar(10));
create hash index x1 on test1(a);
insert into test1 values ('abcaaaa'),('abcbbbb'),('abccccc'),('abcdddd');
insert into test1 values ('abcaaaa'),('abcbbbb'),('abccccc'),('abcdddd');
insert into test1 values ('abcaaaa'),('abcbbbb'),('abccccc'),('abcdddd');
insert into test1 values ('abcaaaa'),('abcbbbb'),('abccccc'),('abcdddd');
select count(*) from test1 where a='abcaaaa';
> 4;
select count(*) from test1 where a='abcbbbb';
> 4;
@reconnect;
select count(*) from test1 where a='abccccc';
> 4;
select count(*) from test1 where a='abcdddd';
> 4;
update test1 set a='abccccc' where a='abcdddd';
select count(*) from test1 where a='abccccc';
> 8;
select count(*) from test1 where a='abcdddd';
> 0;
delete from test1 where a='abccccc';
select count(*) from test1 where a='abccccc';
> 0;
truncate table test1;
insert into test1 values ('abcaaaa');
insert into test1 values ('abcaaaa');
delete from test1;
drop table test1;
@reconnect;

drop table if exists test;
create table if not exists test(col1 int primary key);
insert into test values(1);
insert into test values(2);
insert into test values(3);
select count(*) from test;
> 3;
select max(col1) from test;
> 3;
update test set col1 = col1 + 1 order by col1 asc limit 100;
select count(*) from test;
> 3;
select max(col1) from test;
> 4;
drop table if exists test;

