/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ignite.internal.processors.query.h2.sql;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Set;
import org.apache.ignite.IgniteCheckedException;
import org.apache.ignite.IgniteException;
import org.apache.ignite.internal.processors.cache.GridCacheContext;
import org.apache.ignite.internal.processors.cache.query.GridCacheSqlQuery;
import org.apache.ignite.internal.processors.cache.query.GridCacheTwoStepQuery;
import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;
import org.apache.ignite.internal.processors.query.h2.opt.GridH2AbstractKeyValueRow;
import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;
import org.apache.ignite.internal.util.lang.GridTriple;
import org.apache.ignite.internal.util.lang.IgnitePair;
import org.apache.ignite.internal.util.typedef.F;
import org.apache.ignite.internal.util.typedef.X;
import org.apache.ignite.internal.util.typedef.internal.U;
import org.apache.ignite.lang.IgnitePredicate;
import org.h2.command.Prepared;
import org.h2.command.dml.Delete;
import org.h2.command.dml.Explain;
import org.h2.command.dml.Insert;
import org.h2.command.dml.Merge;
import org.h2.command.dml.Query;
import org.h2.command.dml.Update;
import org.h2.jdbc.JdbcPreparedStatement;
import org.h2.table.Column;
import org.h2.table.IndexColumn;
import org.h2.util.IntArray;
import org.jetbrains.annotations.Nullable;

import static org.apache.ignite.internal.processors.query.h2.opt.GridH2CollocationModel.isCollocated;
import static org.apache.ignite.internal.processors.query.h2.sql.GridSqlFunctionType.AVG;
import static org.apache.ignite.internal.processors.query.h2.sql.GridSqlFunctionType.CAST;
import static org.apache.ignite.internal.processors.query.h2.sql.GridSqlFunctionType.COUNT;
import static org.apache.ignite.internal.processors.query.h2.sql.GridSqlFunctionType.SUM;
import static org.apache.ignite.internal.processors.query.h2.sql.GridSqlPlaceholder.EMPTY;
import static org.apache.ignite.internal.processors.query.h2.sql.GridSqlQueryParser.prepared;
import static org.apache.ignite.internal.processors.query.h2.sql.GridSqlQueryParser.query;
import static org.apache.ignite.internal.processors.query.h2.twostep.GridReduceQueryExecutor.toArray;

/**
 * Splits a single SQL query into two step map-reduce query.
 */
public class GridSqlQuerySplitter {
    /** */
    private static final String TABLE_SCHEMA = "PUBLIC";

    /** */
    private static final String TABLE_PREFIX = "__T";

    /** */
    private static final String COLUMN_PREFIX = "__C";

    /** */
    private static final String HAVING_COLUMN = "__H";

    /**
     * @param idx Index of table.
     * @return Table.
     */
    public static GridSqlTable table(int idx) {
        return new GridSqlTable(TABLE_SCHEMA, TABLE_PREFIX + idx);
    }

    /**
     * @param idx Index of column.
     * @return Generated by index column alias.
     */
    private static String columnName(int idx) {
        return COLUMN_PREFIX + idx;
    }

    /**
     * @param qry Query.
     * @return Leftest simple query if this is UNION.
     */
    private static GridSqlSelect leftest(GridSqlQuery qry) {
        if (qry instanceof GridSqlUnion)
            return leftest(((GridSqlUnion)qry).left());

        return (GridSqlSelect)qry;
    }

    /**
     * @param qry Query.
     * @return Select query.
     */
    private static GridSqlSelect wrapUnion(GridSqlQuery qry) {
        if (qry instanceof GridSqlSelect)
            return (GridSqlSelect)qry;

        // Handle UNION.
        GridSqlSelect wrapQry = new GridSqlSelect().from(new GridSqlSubquery(qry));

        wrapQry.explain(qry.explain());
        qry.explain(false);

        GridSqlSelect left = leftest(qry);

        int c = 0;

        for (GridSqlElement expr : left.columns(true)) {
            GridSqlType type = expr.resultType();

            String colName;

            if (expr instanceof GridSqlAlias)
                colName = ((GridSqlAlias)expr).alias();
            else if (expr instanceof GridSqlColumn)
                colName = ((GridSqlColumn)expr).columnName();
            else {
                colName = columnName(c);

                expr = alias(colName, expr);

                // Set generated alias to the expression.
                left.setColumn(c, expr);
            }

            GridSqlColumn col = column(colName);

            col.resultType(type);

            wrapQry.addColumn(col, true);

            c++;
        }

        // ORDER BY
        if (!qry.sort().isEmpty()) {
            for (GridSqlSortColumn col : qry.sort())
                wrapQry.addSort(col);
        }

        return wrapQry;
    }

    /**
     * @param stmt Prepared statement.
     * @param params Parameters.
     * @param injectKeysFilter Whether only specific keys must be selected.
     * @param collocatedGrpBy Whether the query has collocated GROUP BY keys.
     * @param distributedJoins If distributed joins enabled.
     * @return Two step query.
     */
    public static GridCacheTwoStepQuery split(JdbcPreparedStatement stmt, Object[] params, Object[] injectKeysFilter,
        boolean collocatedGrpBy, boolean distributedJoins) throws IgniteCheckedException {
        if (params == null)
            params = GridCacheSqlQuery.EMPTY_PARAMS;

        final Prepared prepared = prepared(stmt);

        if (prepared instanceof Query || prepared instanceof Explain)
            return splitQueryStatement(GridSqlQueryParser.query(prepared), params, prepared instanceof Explain,
                collocatedGrpBy, distributedJoins);

        if (prepared instanceof Merge || prepared instanceof Update || prepared instanceof Insert ||
            prepared instanceof Delete)
            return splitUpdateQuery(prepared, params, injectKeysFilter, collocatedGrpBy, distributedJoins);

        throw new UnsupportedOperationException("Query not supported [cls=" + prepared.getClass().getName() + "]");
    }

    /**
     * @param prepared Prepared SQL SELECT or UNION statement.
     * @param params Parameters.
     * @param collocatedGrpBy Collocated query.
     * @param distributedJoins If distributed joins enabled.
     * @return Two step query.
     */
    private static GridCacheTwoStepQuery splitQueryStatement(
        Query prepared,
        Object[] params,
        boolean explain,
        final boolean collocatedGrpBy,
        final boolean distributedJoins
    ) throws IgniteCheckedException {
        GridSqlStatement gridStmt = new GridSqlQueryParser().parse(prepared);
        X.ensureX(gridStmt instanceof GridSqlQuery, "SQL query expected");
        gridStmt.explain(explain);
        return splitQuery((GridSqlQuery) gridStmt, params, collocatedGrpBy,
            distributedJoins && !isCollocated(query(prepared)));
    }

    /**
     * @param qry Grid SQL select or union.
     * @param params Parameters.
     * @param collocatedGrpBy Collocated query.
     * @param distributedJoins If distributed joins enabled.
     * @return Two step query.
     */
    private static GridCacheTwoStepQuery splitQuery(
        GridSqlQuery qry,
        Object[] params,
        final boolean collocatedGrpBy,
        final boolean distributedJoins
    ) {
        Set<String> tbls = new HashSet<>();
        Set<String> schemas = new HashSet<>();

        qry = collectAllTables(qry, schemas, tbls);

        // Build resulting two step query.
        GridCacheTwoStepQuery res = new GridCacheTwoStepQuery(schemas, tbls);

        // Map query will be direct reference to the original query AST.
        // Thus all the modifications will be performed on the original AST, so we should be careful when
        // nullifying or updating things, have to make sure that we will not need them in the original form later.
        final GridSqlSelect mapQry = wrapUnion(qry);

        GridCacheSqlQuery rdc = split(res, 0, mapQry, params, collocatedGrpBy);

        res.reduceQuery(rdc);
        res.initialStatement(qry);

        // We do not have to look at each map query separately here, because if
        // the whole initial query is collocated, then all the map sub-queries
        // will be collocated as well.
        res.distributedJoins(distributedJoins);

        return res;
    }

    /**
     * @param prepared Prepared SQL INSERT, MERGE, UPDATE, or DELETE statement.
     * @param params Parameters.
     * @param keysFilter Whether only specific keys must be selected.
     * @param collocatedGrpBy Collocated SELECT (for WHERE and subqueries).
     * @param distributedJoins If distributed joins enabled.    @return Two step query.
     */
    private static GridCacheTwoStepQuery splitUpdateQuery(Prepared prepared, Object[] params, Object[] keysFilter,
        boolean collocatedGrpBy, final boolean distributedJoins) throws IgniteCheckedException {
        GridSqlStatement gridStmt = new GridSqlQueryParser().parse(prepared);

        X.ensureX(gridStmt instanceof GridSqlInsert || gridStmt instanceof GridSqlMerge ||
            gridStmt instanceof GridSqlUpdate || gridStmt instanceof GridSqlDelete, "SQL update operation expected");

        if (gridStmt instanceof GridSqlUpdate)
            return splitUpdate((GridSqlUpdate)gridStmt, params, keysFilter, collocatedGrpBy, distributedJoins);

        if (gridStmt instanceof GridSqlDelete)
            return splitDelete((GridSqlDelete)gridStmt, params, keysFilter, collocatedGrpBy, distributedJoins);

        GridSqlElement target;

        GridSqlQuery sel;

        boolean hasRows;

        if (gridStmt instanceof GridSqlInsert) {
            GridSqlInsert ins = (GridSqlInsert) gridStmt;
            target = ins.into();
            hasRows = !F.isEmpty(ins.rows());
            sel = selectForInsertOrMerge(ins.rows(), ins.query());
        }
        else {
            GridSqlMerge merge = (GridSqlMerge) gridStmt;
            target = merge.into();
            hasRows = !F.isEmpty(merge.rows());
            sel = selectForInsertOrMerge(merge.rows(), merge.query());
        }

        X.ensureX(target != null, "Failed to retrieve target for SQL update operation");

        // Build resulting two step query.
        GridCacheTwoStepQuery res;

        if (!hasRows) // INSERT or MERGE from SELECT
            res = splitQuery(sel, params, collocatedGrpBy, distributedJoins);
        else {
            res = new GridCacheTwoStepQuery(new HashSet<String>(), new HashSet<String>());

            IntArray paramIdxs = new IntArray(params.length);

            GridCacheSqlQuery rdc = new GridCacheSqlQuery(sel.getSQL(),
                findParams(sel, params, new ArrayList<>(), paramIdxs).toArray());

            rdc.parameterIndexes(toArray(paramIdxs));

            res.reduceQuery(rdc);

            // We do not have to look at each map query separately here, because if
            // the whole initial query is collocated, then all the map sub-queries
            // will be collocated as well.
            //
            // Statement left for clarity - currently update operations don't really care much about joins.
            res.distributedJoins(distributedJoins && !isCollocated(query(prepared)));
        }

        collectAllTablesInFrom(target, res.schemas(), res.tables());

        res.initialStatement(gridStmt);

        return res;
    }

    /**
     * Create SELECT on which subsequent INSERT or MERGE will be based.
     *
     * @param rows Rows to create pseudo-SELECT upon.
     * @param subQry Subquery to use rather than rows.
     * @return Subquery or pseudo-SELECT to evaluate inserted expressions.
     */
    public static GridSqlQuery selectForInsertOrMerge(List<GridSqlElement[]> rows, GridSqlQuery subQry) {
        if (!F.isEmpty(rows)) {
            GridSqlSelect sel = new GridSqlSelect();

            for (GridSqlElement[] row : rows)
                sel.addColumn(new GridSqlArray(F.asList(row)), true);

            return sel;
        }
        else {
            assert subQry != null;

            return subQry;
        }
    }

    /** */
    @SuppressWarnings("ConstantConditions")
    private static GridCacheTwoStepQuery splitDelete(GridSqlDelete del, Object[] params, Object[] keysFilter,
        boolean collocatedGrpBy, boolean distributedJoins) throws IgniteCheckedException {
        GridTriple<GridSqlElement> singleUpdate = getSingleItemFilter(del);

        if (singleUpdate != null)
            return twoStepQueryForSingleItem(del, del.from(), singleUpdate);

        int paramsCnt = F.isEmpty(params) ? 0 : params.length;
        GridSqlSelect mapQry = mapQueryForDelete(del, !F.isEmpty(keysFilter) ? paramsCnt : null);

        params = Arrays.copyOf(U.firstNotNull(params, X.EMPTY_OBJECT_ARRAY), paramsCnt + 1);
        params[paramsCnt] = keysFilter;

        GridCacheTwoStepQuery res = splitQuery(mapQry, params, collocatedGrpBy, distributedJoins);
        res.initialStatement(del);

        return res;
    }

    /**
     * Generate SQL SELECT based on DELETE's WHERE, LIMIT, etc.
     *
     * @param del Delete statement.
     * @param keysParamIdx Index for .
     * @return SELECT statement.
     */
    public static GridSqlSelect mapQueryForDelete(GridSqlDelete del, @Nullable Integer keysParamIdx)
        throws IgniteCheckedException {
        GridSqlSelect mapQry = new GridSqlSelect();

        mapQry.from(del.from());

        Set<GridSqlTable> tbls = new HashSet<>();

        collectAllGridTablesInTarget(del.from(), tbls);

        X.ensureX(tbls.size() == 1, "Failed to determine target table for DELETE");

        GridSqlTable tbl = tbls.iterator().next();

        GridH2Table gridTbl = tbl.dataTable();

        X.ensureX(gridTbl != null, "Failed to determine target grid table for DELETE");

        Column h2KeyCol = gridTbl.getColumn(GridH2AbstractKeyValueRow.KEY_COL);

        Column h2ValCol = gridTbl.getColumn(GridH2AbstractKeyValueRow.VAL_COL);

        GridSqlColumn keyCol = new GridSqlColumn(h2KeyCol, tbl, h2KeyCol.getName(), h2KeyCol.getSQL());
        keyCol.resultType(GridSqlType.fromColumn(h2KeyCol));

        GridSqlColumn valCol = new GridSqlColumn(h2ValCol, tbl, h2ValCol.getName(), h2ValCol.getSQL());
        valCol.resultType(GridSqlType.fromColumn(h2ValCol));

        mapQry.addColumn(keyCol, true);
        mapQry.addColumn(valCol, true);

        GridSqlElement where = del.where();
        if (keysParamIdx != null)
            where = injectKeysFilterParam(where, keyCol, keysParamIdx);

        mapQry.where(where);
        mapQry.limit(del.limit());

        return mapQry;
    }

    /** */
    @SuppressWarnings("ConstantConditions")
    private static GridCacheTwoStepQuery splitUpdate(GridSqlUpdate update, Object[] params, Object[] keysFilter,
        boolean collocatedGrpBy, boolean distributedJoins) throws IgniteCheckedException {
        GridTriple<GridSqlElement> singleUpdate = getSingleItemFilter(update);

        if (singleUpdate != null)
            return twoStepQueryForSingleItem(update, update.target(), singleUpdate);

        int paramsCnt = F.isEmpty(params) ? 0 : params.length;
        GridSqlSelect mapQry = mapQueryForUpdate(update, !F.isEmpty(keysFilter) ? paramsCnt: null);

        params = Arrays.copyOf(U.firstNotNull(params, X.EMPTY_OBJECT_ARRAY), paramsCnt + 1);
        params[paramsCnt] = keysFilter;

        GridCacheTwoStepQuery res = splitQuery(mapQry, params, collocatedGrpBy, distributedJoins);
        res.initialStatement(update);

        return res;
    }


    /**
     * @param stmt Initial statement.
     * @param target Table or alias the statement points to.
     * @param singleUpdate Operation arguments.
     * @return Empty two step query that bears only initial statement and single operation arguments.
     */
    private static GridCacheTwoStepQuery twoStepQueryForSingleItem(GridSqlStatement stmt,
        GridSqlElement target, GridTriple<GridSqlElement> singleUpdate) {
        Set<String> schemas = new HashSet<>();
        Set<String> tbls = new HashSet<>();

        collectAllTablesInFrom(target, schemas, tbls);

        // No need to do any more parsing - we know that this statement affects one item at most.
        GridCacheTwoStepQuery res = new GridCacheTwoStepQuery(schemas, tbls);

        res.initialStatement(stmt);
        res.singleUpdate(singleUpdate);

        return res;
    }

    /**
     * @param update UPDATE statement.
     * @return {@code null} if given statement directly updates {@code _val} column with a literal or param value
     * and filters by single non expression key (and, optionally,  by single non expression value).
     */
    public static GridTriple<GridSqlElement> getSingleItemFilter(GridSqlUpdate update) {
        IgnitePair<GridSqlElement> filter = findKeyValueEqulaityCondition(update.where());

        if (filter == null)
            return null;

        if (update.cols().size() != 1 ||
            !IgniteH2Indexing.VAL_FIELD_NAME.equalsIgnoreCase(update.cols().get(0).columnName()))
            return null;

        GridSqlElement set = update.set().get(update.cols().get(0).columnName());

        if (!(set instanceof GridSqlConst || set instanceof GridSqlParameter))
            return null;

        return new GridTriple<>(filter.getKey(), filter.getValue(), set);
    }

    /**
     * @param del DELETE statement.
     * @return {@code true} if given statement filters by single non expression key.
     */
    public static GridTriple<GridSqlElement> getSingleItemFilter(GridSqlDelete del) {
        IgnitePair<GridSqlElement> filter = findKeyValueEqulaityCondition(del.where());

        if (filter == null)
            return null;

        return new GridTriple<>(filter.getKey(), filter.getValue(), null);
    }

    /**
     * @param where Element to test.
     * @return Whether given element corresponds to {@code WHERE _key = ?}, and key is a literal expressed
     * in query or a query param.
     */
    private static IgnitePair<GridSqlElement> findKeyValueEqulaityCondition(GridSqlElement where) {
        if (where == null || !(where instanceof GridSqlOperation))
            return null;

        GridSqlOperation whereOp = (GridSqlOperation) where;

        // Does this WHERE limit only by _key?
        if (isKeyEqualityCondition(whereOp))
            return new IgnitePair<>(whereOp.child(1), null);

        // Or maybe it limits both by _key and _val?
        if (whereOp.operationType() != GridSqlOperationType.AND)
            return null;

        GridSqlElement left = whereOp.child(0);

        GridSqlElement right = whereOp.child(1);

        if (!(left instanceof GridSqlOperation && right instanceof GridSqlOperation))
            return null;

        GridSqlOperation leftOp = (GridSqlOperation) left;

        GridSqlOperation rightOp = (GridSqlOperation) right;

        if (isKeyEqualityCondition(leftOp)) { // _key = ? and _val = ?
            if (!isValueEqualityCondition(rightOp))
                return null;

            return new IgnitePair<>(leftOp.child(1), rightOp.child(1));
        }
        else if (isKeyEqualityCondition(rightOp)) { // _val = ? and _key = ?
            if (!isValueEqualityCondition(leftOp))
                return null;

            return new IgnitePair<>(rightOp.child(1), leftOp.child(1));
        }
        else // Neither
            return null;
    }

    /**
     * @param op Operation.
     * @param colName Column name to check.
     * @return Whether this condition is of form {@code colName} = ?
     */
    private static boolean isEqualityCondition(GridSqlOperation op, String colName) {
        if (op.operationType() != GridSqlOperationType.EQUAL)
            return false;

        GridSqlElement left = op.child(0);
        GridSqlElement right = op.child(1);

        return left instanceof GridSqlColumn &&
            colName.equalsIgnoreCase(((GridSqlColumn) left).columnName()) &&
            (right instanceof GridSqlConst || right instanceof GridSqlParameter);
    }

    /**
     * @param op Operation.
     * @return Whether this condition is of form _key = ?
     */
    private static boolean isKeyEqualityCondition(GridSqlOperation op) {
        return isEqualityCondition(op, IgniteH2Indexing.KEY_FIELD_NAME);
    }

    /**
     * @param op Operation.
     * @return Whether this condition is of form _val = ?
     */
    private static boolean isValueEqualityCondition(GridSqlOperation op) {
        return isEqualityCondition(op, IgniteH2Indexing.VAL_FIELD_NAME);
    }


    /**
     * Generate SQL SELECT based on UPDATE's WHERE, LIMIT, etc.
     *
     * @param update Update statement.
     * @param keysParamIdx Index of new param for the array of keys.
     * @return SELECT statement.
     */
    public static GridSqlSelect mapQueryForUpdate(GridSqlUpdate update, @Nullable Integer keysParamIdx)
        throws IgniteCheckedException {
        GridSqlSelect mapQry = new GridSqlSelect();

        mapQry.from(update.target());

        Set<GridSqlTable> tbls = new HashSet<>();

        collectAllGridTablesInTarget(update.target(), tbls);

        X.ensureX(tbls.size() == 1, "Failed to determine target table for UPDATE");

        GridSqlTable tbl = tbls.iterator().next();

        GridH2Table gridTbl = tbl.dataTable();

        X.ensureX(gridTbl != null, "Failed to determine target grid table for UPDATE");

        Column h2KeyCol = gridTbl.getColumn(GridH2AbstractKeyValueRow.KEY_COL);

        Column h2ValCol = gridTbl.getColumn(GridH2AbstractKeyValueRow.VAL_COL);

        GridSqlColumn keyCol = new GridSqlColumn(h2KeyCol, tbl, h2KeyCol.getName(), h2KeyCol.getSQL());
        keyCol.resultType(GridSqlType.fromColumn(h2KeyCol));

        GridSqlColumn valCol = new GridSqlColumn(h2ValCol, tbl, h2ValCol.getName(), h2ValCol.getSQL());
        valCol.resultType(GridSqlType.fromColumn(h2ValCol));

        mapQry.addColumn(keyCol, true);
        mapQry.addColumn(valCol, true);

        for (GridSqlColumn c : update.cols()) {
            String newColName = "_upd_" + c.columnName();
            // We have to use aliases to cover cases when the user
            // wants to update _val field directly (if it's a literal)
            GridSqlAlias alias = new GridSqlAlias(newColName, update.set().get(c.columnName()), true);
            alias.resultType(c.resultType());
            mapQry.addColumn(alias, true);
        }

        GridSqlElement where = update.where();
        if (keysParamIdx != null)
            where = injectKeysFilterParam(where, keyCol, keysParamIdx);

        mapQry.where(where);
        mapQry.limit(update.limit());

        return mapQry;
    }

    /**
     * Append additional condition to WHERE for it to select only specific keys.
     *
     * @param where Initial condition.
     * @param keyCol Column to base the new condition on.
     * @return New condition.
     */
    private static GridSqlElement injectKeysFilterParam(GridSqlElement where, GridSqlColumn keyCol, int paramIdx) {
        GridSqlElement e = new GridSqlOperation(GridSqlOperationType.IN, keyCol, new GridSqlParameter(paramIdx));

        if (where == null)
            return e;
        else
            return new GridSqlOperation(GridSqlOperationType.AND, where, e);
    }

    /**
     * @param el Either {@link GridSqlSelect#from()} or {@link GridSqlSelect#where()} elements.
     */
    private static void findAffinityColumnConditions(GridSqlElement el) {
        if (el == null)
            return;

        el = GridSqlAlias.unwrap(el);

        if (el instanceof GridSqlJoin) {
            GridSqlJoin join = (GridSqlJoin)el;

            findAffinityColumnConditions(join.leftTable());
            findAffinityColumnConditions(join.rightTable());
            findAffinityColumnConditions(join.on());
        }
        else if (el instanceof GridSqlOperation) {
            GridSqlOperationType type = ((GridSqlOperation)el).operationType();

            switch(type) {
                case AND:
                    findAffinityColumnConditions(el.child(0));
                    findAffinityColumnConditions(el.child(1));

                    break;

                case EQUAL:
                    findAffinityColumn(el.child(0));
                    findAffinityColumn(el.child(1));
            }
        }
    }

    /**
     * @param exp Possible affinity column expression.
     */
    private static void findAffinityColumn(GridSqlElement exp) {
        if (exp instanceof GridSqlColumn) {
            GridSqlColumn col = (GridSqlColumn)exp;

            GridSqlElement from = col.expressionInFrom();

            if (from instanceof GridSqlTable) {
                GridSqlTable fromTbl = (GridSqlTable)from;

                GridH2Table tbl = fromTbl.dataTable();

                if (tbl != null) {
                    IndexColumn affKeyCol = tbl.getAffinityKeyColumn();
                    Column expCol = col.column();

                    if (affKeyCol != null && expCol != null &&
                        affKeyCol.column.getColumnId() == expCol.getColumnId()) {
                        // Mark that table lookup will use affinity key.
                        fromTbl.affinityKeyCondition(true);
                    }
                }
            }
        }
    }

    /**
     * @param qry Select.
     * @return {@code true} If there is at least one partitioned table in FROM clause.
     */
    private static boolean hasPartitionedTableInFrom(GridSqlSelect qry) {
        return findTablesInFrom(qry.from(), new IgnitePredicate<GridSqlElement>() {
            @Override public boolean apply(GridSqlElement el) {
                if (el instanceof GridSqlTable) {
                    GridH2Table tbl = ((GridSqlTable)el).dataTable();

                    assert tbl != null : el;

                    GridCacheContext<?,?> cctx = tbl.rowDescriptor().context();

                    return !cctx.isLocal() && !cctx.isReplicated();
                }

                return false;
            }
        });
    }

    /**
     * @param res Resulting two step query.
     * @param splitIdx Split index.
     * @param mapQry Map query to be split.
     * @param params Query parameters.
     * @param collocatedGroupBy Whether the query has collocated GROUP BY keys.
     * @return Reduce query for the given map query.
     */
    private static GridCacheSqlQuery split(GridCacheTwoStepQuery res, int splitIdx, final GridSqlSelect mapQry,
        Object[] params, boolean collocatedGroupBy) {
        final boolean explain = mapQry.explain();

        mapQry.explain(false);

        GridSqlSelect rdcQry = new GridSqlSelect().from(table(splitIdx));

        // Split all select expressions into map-reduce parts.
        List<GridSqlElement> mapExps = new ArrayList<>(mapQry.allColumns());

        mapExps.addAll(mapQry.columns(false));

        final int visibleCols = mapQry.visibleColumns();
        final int havingCol = mapQry.havingColumn();

        List<GridSqlElement> rdcExps = new ArrayList<>(visibleCols);

        Set<String> colNames = new HashSet<>();

        boolean aggregateFound = false;

        for (int i = 0, len = mapExps.size(); i < len; i++) // Remember len because mapExps list can grow.
            aggregateFound |= splitSelectExpression(mapExps, rdcExps, colNames, i, collocatedGroupBy, i == havingCol);

        // -- SELECT
        mapQry.clearColumns();

        for (GridSqlElement exp : mapExps) // Add all map expressions as visible.
            mapQry.addColumn(exp, true);

        for (int i = 0; i < visibleCols; i++) // Add visible reduce columns.
            rdcQry.addColumn(rdcExps.get(i), true);

        for (int i = visibleCols; i < rdcExps.size(); i++) // Add invisible reduce columns (HAVING).
            rdcQry.addColumn(rdcExps.get(i), false);

        for (int i = rdcExps.size(); i < mapExps.size(); i++)  // Add all extra map columns as invisible reduce columns.
            rdcQry.addColumn(column(((GridSqlAlias)mapExps.get(i)).alias()), false);

        // -- FROM
        findAffinityColumnConditions(mapQry.from());

        // -- WHERE
        findAffinityColumnConditions(mapQry.where());

        // -- GROUP BY
        if (mapQry.groupColumns() != null && !collocatedGroupBy)
            rdcQry.groupColumns(mapQry.groupColumns());

        // -- HAVING
        if (havingCol >= 0 && !collocatedGroupBy) {
            // TODO IGNITE-1140 - Find aggregate functions in HAVING clause or rewrite query to put all aggregates to SELECT clause.
            // We need to find HAVING column in reduce query.
            for (int i = visibleCols; i < rdcQry.allColumns(); i++) {
                GridSqlElement c = rdcQry.column(i);

                if (c instanceof GridSqlAlias && HAVING_COLUMN.equals(((GridSqlAlias)c).alias())) {
                    rdcQry.havingColumn(i);

                    break;
                }
            }

            mapQry.havingColumn(-1);
        }

        // -- ORDER BY
        if (!mapQry.sort().isEmpty()) {
            for (GridSqlSortColumn sortCol : mapQry.sort())
                rdcQry.addSort(sortCol);

            if (aggregateFound) // Ordering over aggregates does not make sense.
                mapQry.clearSort(); // Otherwise map sort will be used by offset-limit.
            // TODO IGNITE-1141 - Check if sorting is done over aggregated expression, otherwise we can sort and use offset-limit.
        }

        // -- LIMIT
        if (mapQry.limit() != null) {
            rdcQry.limit(mapQry.limit());

            if (aggregateFound)
                mapQry.limit(null);
        }

        // -- OFFSET
        if (mapQry.offset() != null) {
            rdcQry.offset(mapQry.offset());

            if (mapQry.limit() != null) // LIMIT off + lim
                mapQry.limit(op(GridSqlOperationType.PLUS, mapQry.offset(), mapQry.limit()));

            mapQry.offset(null);
        }

        // -- DISTINCT
        if (mapQry.distinct()) {
            mapQry.distinct(!aggregateFound && mapQry.groupColumns() == null && mapQry.havingColumn() < 0);
            rdcQry.distinct(true);
        }

        IntArray paramIdxs = new IntArray(params.length);

        GridCacheSqlQuery map = new GridCacheSqlQuery(mapQry.getSQL(),
            findParams(mapQry, params, new ArrayList<>(params.length), paramIdxs).toArray());

        map.columns(collectColumns(mapExps));
        map.parameterIndexes(toArray(paramIdxs));

        res.addMapQuery(map);

        res.explain(explain);

        paramIdxs = new IntArray(params.length);

        GridCacheSqlQuery rdc = new GridCacheSqlQuery(rdcQry.getSQL(),
            findParams(rdcQry, params, new ArrayList<>(), paramIdxs).toArray());

        rdc.parameterIndexes(toArray(paramIdxs));
        res.skipMergeTable(rdcQry.simpleQuery());

        return rdc;
    }

    /**
     * @param cols Columns from SELECT clause.
     * @return Map of columns with types.
     */
    private static LinkedHashMap<String,?> collectColumns(List<GridSqlElement> cols) {
        LinkedHashMap<String, GridSqlType> res = new LinkedHashMap<>(cols.size(), 1f, false);

        for (int i = 0; i < cols.size(); i++) {
            GridSqlElement col = cols.get(i);
            GridSqlType t = col.resultType();

            if (t == null)
                throw new NullPointerException("Column type.");

            if (t == GridSqlType.UNKNOWN)
                throw new IllegalStateException("Unknown type: " + col);

            String alias;

            if (col instanceof GridSqlAlias)
                alias = ((GridSqlAlias)col).alias();
            else
                alias = columnName(i);

            if (res.put(alias, t) != null)
                throw new IllegalStateException("Alias already exists: " + alias);
        }

        return res;
    }

    /**
     * @param qry Query.
     * @param schemas Schema names.
     * @param tbls Tables.
     * @return Query.
     */
    private static GridSqlQuery collectAllTables(GridSqlQuery qry, Set<String> schemas, Set<String> tbls) {
        if (qry instanceof GridSqlUnion) {
            GridSqlUnion union = (GridSqlUnion)qry;

            collectAllTables(union.left(), schemas, tbls);
            collectAllTables(union.right(), schemas, tbls);
        }
        else {
            GridSqlSelect select = (GridSqlSelect)qry;

            collectAllTablesInFrom(select.from(), schemas, tbls);

            for (GridSqlElement el : select.columns(false))
                collectAllTablesInSubqueries(el, schemas, tbls);

            collectAllTablesInSubqueries(select.where(), schemas, tbls);
        }

        return qry;
    }

    /**
     * @param from From element.
     * @param schemas Schema names.
     * @param tbls Tables.
     */
    private static void collectAllTablesInFrom(GridSqlElement from, final Set<String> schemas, final Set<String> tbls) {
        findTablesInFrom(from, new IgnitePredicate<GridSqlElement>() {
            @Override public boolean apply(GridSqlElement el) {
                if (el instanceof GridSqlTable) {
                    GridSqlTable tbl = (GridSqlTable)el;

                    String schema = tbl.schema();

                    boolean addSchema = tbls == null;

                    if (tbls != null)
                        addSchema = tbls.add(tbl.dataTable().identifier());

                    if (addSchema && schema != null && schemas != null)
                        schemas.add(schema);
                }
                else if (el instanceof GridSqlSubquery)
                    collectAllTables(((GridSqlSubquery)el).select(), schemas, tbls);

                return false;
            }
        });
    }

    /**
     * @param from From element.
     * @param tbls Tables.
     */
    public static void collectAllGridTablesInTarget(GridSqlElement from, final Set<GridSqlTable> tbls) {
        findTablesInFrom(from, new IgnitePredicate<GridSqlElement>() {
            @Override public boolean apply(GridSqlElement el) {
                if (el instanceof GridSqlTable)
                    tbls.add((GridSqlTable)el);

                return false;
            }
        });
    }

    /**
     * Processes all the tables and subqueries using the given closure.
     *
     * @param from FROM element.
     * @param c Closure each found table and subquery will be passed to. If returns {@code true} the we need to stop.
     * @return {@code true} If we have found.
     */
    private static boolean findTablesInFrom(GridSqlElement from, IgnitePredicate<GridSqlElement> c) {
        if (from == null)
            return false;

        if (from instanceof GridSqlTable || from instanceof GridSqlSubquery)
            return c.apply(from);

        if (from instanceof GridSqlJoin) {
            // Left and right.
            if (findTablesInFrom(from.child(0), c))
                return true;

            if (findTablesInFrom(from.child(1), c))
                return true;

            // We don't process ON condition because it is not a joining part of from here.
            return false;
        }
        else if (from instanceof GridSqlAlias)
            return findTablesInFrom(from.child(), c);
        else if (from instanceof GridSqlFunction)
            return false;

        throw new IllegalStateException(from.getClass().getName() + " : " + from.getSQL());
    }

    /**
     * Searches schema names and tables in subqueries in SELECT and WHERE clauses.
     *
     * @param el Element.
     * @param schemas Schema names.
     * @param tbls Tables.
     */
    private static void collectAllTablesInSubqueries(GridSqlElement el, Set<String> schemas, Set<String> tbls) {
        if (el == null)
            return;

        el = GridSqlAlias.unwrap(el);

        if (el instanceof GridSqlOperation || el instanceof GridSqlFunction) {
            for (GridSqlElement child : el)
                collectAllTablesInSubqueries(child, schemas, tbls);
        }
        else if (el instanceof GridSqlSubquery)
            collectAllTables(((GridSqlSubquery)el).select(), schemas, tbls);
    }

    /**
     * @param stmt Statement.
     * @param params Parameters.
     * @param target Extracted parameters.
     * @param paramIdxs Parameter indexes.
     * @return Extracted parameters list.
     */
    private static List<Object> findParams(GridSqlStatement stmt, Object[] params, ArrayList<Object> target,
                                           IntArray paramIdxs) {
        if (stmt instanceof GridSqlQuery)
            return findParams((GridSqlQuery)stmt, params, target, paramIdxs);

        if (stmt instanceof GridSqlMerge)
            return findParams((GridSqlMerge)stmt, params, target, paramIdxs);

        if (stmt instanceof GridSqlInsert)
            return findParams((GridSqlInsert)stmt, params, target, paramIdxs);

        return target;
    }

    /**
     * @param qry Select.
     * @param params Parameters.
     * @param target Extracted parameters.
     * @param paramIdxs Parameter indexes.
     * @return Extracted parameters list.
     */
    private static List<Object> findParams(GridSqlQuery qry, Object[] params, ArrayList<Object> target,
        IntArray paramIdxs) {
        if (qry instanceof GridSqlSelect)
            return findParams((GridSqlSelect)qry, params, target, paramIdxs);

        GridSqlUnion union = (GridSqlUnion)qry;

        findParams(union.left(), params, target, paramIdxs);
        findParams(union.right(), params, target, paramIdxs);

        findParams(qry.limit(), params, target, paramIdxs);
        findParams(qry.offset(), params, target, paramIdxs);

        return target;
    }

    /**
     * @param qry Select.
     * @param params Parameters.
     * @param target Extracted parameters.
     * @param paramIdxs Parameter indexes.
     * @return Extracted parameters list.
     */
    private static List<Object> findParams(GridSqlSelect qry, Object[] params, ArrayList<Object> target,
        IntArray paramIdxs) {
        if (params.length == 0)
            return target;

        for (GridSqlElement el : qry.columns(false))
            findParams(el, params, target, paramIdxs);

        findParams(qry.from(), params, target, paramIdxs);
        findParams(qry.where(), params, target, paramIdxs);

        // Don't search in GROUP BY and HAVING since they expected to be in select list.

        findParams(qry.limit(), params, target, paramIdxs);
        findParams(qry.offset(), params, target, paramIdxs);

        return target;
    }

    /**
     * @param el Element.
     * @param params Parameters.
     * @param target Extracted parameters.
     * @param paramIdxs Parameter indexes.
     */
    private static void findParams(@Nullable GridSqlElement el, Object[] params, ArrayList<Object> target,
        IntArray paramIdxs) {
        if (el == null)
            return;

        if (el instanceof GridSqlParameter) {
            // H2 Supports queries like "select ?5" but first 4 non-existing parameters are need to be set to any value.
            // Here we will set them to NULL.
            final int idx = ((GridSqlParameter)el).index();

            while (target.size() < idx)
                target.add(null);

            if (params.length <= idx)
                throw new IgniteException("Invalid number of query parameters. " +
                    "Cannot find " + idx + " parameter.");

            Object param = params[idx];

            if (idx == target.size())
                target.add(param);
            else
                target.set(idx, param);

            paramIdxs.add(idx);
        }
        else if (el instanceof GridSqlSubquery)
            findParams(((GridSqlSubquery)el).select(), params, target, paramIdxs);
        else
            for (GridSqlElement child : el)
                findParams(child, params, target, paramIdxs);
    }

    /**
     * @param stmt Statement.
     * @param params Parameters.
     * @param target Extracted parameters.
     * @param paramIdxs Parameter indexes.
     * @return Extracted parameters list.
     */
    private static List<Object> findParams(GridSqlMerge stmt, Object[] params, ArrayList<Object> target,
                                           IntArray paramIdxs) {
        if (params.length == 0)
            return target;

        for (GridSqlElement el : stmt.columns())
            findParams(el, params, target, paramIdxs);

        for (GridSqlElement[] row : stmt.rows())
            for (GridSqlElement el : row)
                findParams(el, params, target, paramIdxs);

        return target;
    }

    /**
     * @param stmt Statement.
     * @param params Parameters.
     * @param target Extracted parameters.
     * @param paramIdxs Parameter indexes.
     * @return Extracted parameters list.
     */
    private static List<Object> findParams(GridSqlInsert stmt, Object[] params, ArrayList<Object> target,
                                           IntArray paramIdxs) {
        if (params.length == 0)
            return target;

        for (GridSqlElement el : stmt.columns())
            findParams(el, params, target, paramIdxs);

        for (GridSqlElement[] row : stmt.rows())
            for (GridSqlElement el : row)
                findParams(el, params, target, paramIdxs);

        return target;
    }

    /**
     * @param mapSelect Selects for map query.
     * @param rdcSelect Selects for reduce query.
     * @param colNames Set of unique top level column names.
     * @param idx Index.
     * @param collocated If it is a collocated query.
     * @param isHaving If it is a HAVING expression.
     * @return {@code true} If aggregate was found.
     */
    private static boolean splitSelectExpression(List<GridSqlElement> mapSelect, List<GridSqlElement> rdcSelect,
        Set<String> colNames, final int idx, boolean collocated, boolean isHaving) {
        GridSqlElement el = mapSelect.get(idx);

        GridSqlAlias alias = null;

        boolean aggregateFound = false;

        if (el instanceof GridSqlAlias) { // Unwrap from alias.
            alias = (GridSqlAlias)el;
            el = alias.child();
        }

        if (!collocated && hasAggregates(el)) {
            aggregateFound = true;

            if (alias == null)
                alias = alias(isHaving ? HAVING_COLUMN : columnName(idx), el);

            // We can update original alias here as well since it will be dropped from mapSelect.
            splitAggregates(alias, 0, mapSelect, idx, true);

            set(rdcSelect, idx, alias);
        }
        else {
            String mapColAlias = isHaving ? HAVING_COLUMN : columnName(idx);
            String rdcColAlias;

            if (alias == null)  // Original column name for reduce column.
                rdcColAlias = el instanceof GridSqlColumn ? ((GridSqlColumn)el).columnName() : mapColAlias;
            else // Set initial alias for reduce column.
                rdcColAlias = alias.alias();

            // Always wrap map column into generated alias.
            mapSelect.set(idx, alias(mapColAlias, el)); // `el` is known not to be an alias.

            // SELECT __C0 AS original_alias
            GridSqlElement rdcEl = column(mapColAlias);

            if (colNames.add(rdcColAlias)) // To handle column name duplication (usually wildcard for few tables).
                rdcEl = alias(rdcColAlias, rdcEl);

            set(rdcSelect, idx, rdcEl);
        }

        return aggregateFound;
    }

    /**
     * @param list List.
     * @param idx Index.
     * @param item Element.
     */
    private static <Z> void set(List<Z> list, int idx, Z item) {
        assert list.size() == idx;
        list.add(item);
    }

    /**
     * @param el Expression.
     * @return {@code true} If expression contains aggregates.
     */
    private static boolean hasAggregates(GridSqlElement el) {
        if (el instanceof GridSqlAggregateFunction)
            return true;

        for (GridSqlElement child : el) {
            if (hasAggregates(child))
                return true;
        }

        return false;
    }

    /**
     * @param parentExpr Parent expression.
     * @param childIdx Child index to try to split.
     * @param mapSelect List of expressions in map SELECT clause.
     * @param exprIdx Index of the original expression in map SELECT clause.
     * @param first If the first aggregate is already found in this expression.
     * @return {@code true} If the first aggregate is already found.
     */
    private static boolean splitAggregates(
        final GridSqlElement parentExpr,
        final int childIdx,
        final List<GridSqlElement> mapSelect,
        final int exprIdx,
        boolean first) {
        GridSqlElement el = parentExpr.child(childIdx);

        if (el instanceof GridSqlAggregateFunction) {
            splitAggregate(parentExpr, childIdx, mapSelect, exprIdx, first);

            return true;
        }

        for (int i = 0; i < el.size(); i++) {
            if (splitAggregates(el, i, mapSelect, exprIdx, first))
                first = false;
        }

        return !first;
    }

    /**
     * @param parentExpr Parent expression.
     * @param aggIdx Index of the aggregate to split in this expression.
     * @param mapSelect List of expressions in map SELECT clause.
     * @param exprIdx Index of the original expression in map SELECT clause.
     * @param first If this is the first aggregate found in this expression.
     */
    private static void splitAggregate(
        GridSqlElement parentExpr,
        int aggIdx,
        List<GridSqlElement> mapSelect,
        int exprIdx,
        boolean first
    ) {
        GridSqlAggregateFunction agg = parentExpr.child(aggIdx);

        assert agg.resultType() != null;

        GridSqlElement mapAgg, rdcAgg;

        // Create stubbed map alias to fill it with correct expression later.
        GridSqlAlias mapAggAlias = alias(columnName(first ? exprIdx : mapSelect.size()), EMPTY);

        // Replace original expression if it is the first aggregate in expression or add to the end.
        if (first)
            mapSelect.set(exprIdx, mapAggAlias);
        else
            mapSelect.add(mapAggAlias);

        switch (agg.type()) {
            case AVG: // SUM( AVG(CAST(x AS DOUBLE))*COUNT(x) )/SUM( COUNT(x) ).
                //-- COUNT(x) map
                GridSqlElement cntMapAgg = aggregate(agg.distinct(), COUNT)
                    .resultType(GridSqlType.BIGINT).addChild(agg.child());

                // Add generated alias to COUNT(x).
                // Using size as index since COUNT will be added as the last select element to the map query.
                String cntMapAggAlias = columnName(mapSelect.size());

                cntMapAgg = alias(cntMapAggAlias, cntMapAgg);

                mapSelect.add(cntMapAgg);

                //-- AVG(CAST(x AS DOUBLE)) map
                mapAgg = aggregate(agg.distinct(), AVG).resultType(GridSqlType.DOUBLE).addChild(
                    function(CAST).resultType(GridSqlType.DOUBLE).addChild(agg.child()));

                //-- SUM( AVG(x)*COUNT(x) )/SUM( COUNT(x) ) reduce
                GridSqlElement sumUpRdc = aggregate(false, SUM).addChild(
                    op(GridSqlOperationType.MULTIPLY,
                        column(mapAggAlias.alias()),
                        column(cntMapAggAlias)));

                GridSqlElement sumDownRdc = aggregate(false, SUM).addChild(column(cntMapAggAlias));

                rdcAgg = op(GridSqlOperationType.DIVIDE, sumUpRdc, sumDownRdc);

                break;

            case SUM: // SUM( SUM(x) )
            case MAX: // MAX( MAX(x) )
            case MIN: // MIN( MIN(x) )
                mapAgg = aggregate(agg.distinct(), agg.type()).resultType(agg.resultType()).addChild(agg.child());
                rdcAgg = aggregate(agg.distinct(), agg.type()).addChild(column(mapAggAlias.alias()));

                break;

            case COUNT_ALL: // CAST(SUM( COUNT(*) ) AS BIGINT)
            case COUNT: // CAST(SUM( COUNT(x) ) AS BIGINT)
                mapAgg = aggregate(agg.distinct(), agg.type()).resultType(GridSqlType.BIGINT);

                if (agg.type() == COUNT)
                    mapAgg.addChild(agg.child());

                rdcAgg = aggregate(false, SUM).addChild(column(mapAggAlias.alias()));
                rdcAgg = function(CAST).resultType(GridSqlType.BIGINT).addChild(rdcAgg);

                break;

            default:
                throw new IgniteException("Unsupported aggregate: " + agg.type());
        }

        assert !(mapAgg instanceof GridSqlAlias);
        assert mapAgg.resultType() != null;

        // Fill the map alias with aggregate.
        mapAggAlias.child(0, mapAgg);
        mapAggAlias.resultType(mapAgg.resultType());

        // Replace in original expression aggregate with reduce aggregate.
        parentExpr.child(aggIdx, rdcAgg);
    }

    /**
     * @param distinct Distinct.
     * @param type Type.
     * @return Aggregate function.
     */
    private static GridSqlAggregateFunction aggregate(boolean distinct, GridSqlFunctionType type) {
        return new GridSqlAggregateFunction(distinct, type);
    }

    /**
     * @param name Column name.
     * @return Column.
     */
    private static GridSqlColumn column(String name) {
        return new GridSqlColumn(null, null, name, name);
    }

    /**
     * @param alias Alias.
     * @param child Child.
     * @return Alias.
     */
    private static GridSqlAlias alias(String alias, GridSqlElement child) {
        GridSqlAlias res = new GridSqlAlias(alias, child);

        res.resultType(child.resultType());

        return res;
    }

    /**
     * @param type Type.
     * @param left Left expression.
     * @param right Right expression.
     * @return Binary operator.
     */
    private static GridSqlOperation op(GridSqlOperationType type, GridSqlElement left, GridSqlElement right) {
        return new GridSqlOperation(type, left, right);
    }

    /**
     * @param type Type.
     * @return Function.
     */
    private static GridSqlFunction function(GridSqlFunctionType type) {
        return new GridSqlFunction(type);
    }
}